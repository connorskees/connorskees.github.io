<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title> Researching Novel Algorithms to Decode PNG Filters </title><link href=https://connorskees.github.io/fonts.css rel=stylesheet><link href=https://connorskees.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://connorskees.github.io/theme/light.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@500&display=swap" rel=stylesheet><link href=https://connorskees.github.io/override.css rel=stylesheet><link href=https://connorskees.github.io/main.css media=screen rel=stylesheet><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script onload="renderMathInElement(document.body, { delimiters: [
                {left: '$$', right: '$$', display: false},
            ] });" crossorigin=anonymous defer integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js></script><body><script src="https://www.googletagmanager.com/gtag/js?id=G-R0T6WNHCFH" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-R0T6WNHCFH');</script><div class=content><header><div class=main><a href=https://connorskees.github.io></a><div class=socials><a class=social href=https://github.com/connorskees/> <object alt=github data=/social_icons/github.svg height=24 type=image/svg+xml width=24></object> </a></div></div><nav><a style="margin-left: 0.7em" href=/>Home</a></nav></header><main><article><div class=title><div class=page-header>Researching Novel Algorithms to Decode PNG Filters</div><div class=meta>Posted on <time>2023-01-25</time></div></div><section class=body><p>PNG compression involves two schemes — filtering and DEFLATE.<p>Filtering is a pre-processing step that operates row-by-row and is used to decrease entropy in the data. It works off the assumption that pixels and their neighbors are usually similar, but not necessarily the exact same. DEFLATE is a common lossless compression format combining LZ77 and Huffman coding.<p>The step that I'm interested in talking about right now is filtering. You can find a pretty good explanation of the algorithm in the <a href=https://www.w3.org/TR/PNG-Filters.html>PNG specification</a>, but I'll walk through a quick summary of the parts that are relevant to this post.<p>I'll start by introducing two primitives: the pixel, and "bpp" or bits per pixel. PNGs support a number of different color formats, and those formats affect how we encode and decode pixels. There are two properties we care about — color type and bit depth.<p>Color type defines the channels or components that make up a pixel. For example, in the RGBA color type, pixels consist of 4 channels — red, green, blue, and alpha. PNGs support simple grayscale, grayscale with alpha, RGB, RGBA, and an "indexed" color type that lets you assign a single integer to each color.<p>Bit depth defines the number of bits per channel. Certain color types only permit certain bit depths. If you're curious, the list of permitted combinations can be found in <a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#~:Bit%20depth:~:text=The%20allowed%20combinations%20are">the spec</a>.<p>By combining the color type, which defines the number of channels, and the bit depth, which defines the number of bits per channel, we can find the number of bits per pixel. We refer to this value as "bpp." Although <code>bpp</code> typically refers to bits per pixel, for the rest of this post, the "b" in "bpp" will refer to "bytes."<p>Let's look at a simple example:<p>If we have an RGB color type with a bit depth of 8, our bits per pixel is <code>3 * 8</code> or <code>24</code>, and our bytes per pixel is <code>(bits per pixel) / 8</code> = <code>3</code>.<p>When applying filters, the minimum bytes per pixel used is 1, even if the number of bits per pixel is less than a full byte.<p>Filters are applied for every byte, regardless of bit depth. This means that if the number of bits per channel is greater than a full byte, we operate on the bytes of that channel separately.<h2 id=the-png-filters>The PNG Filters</h2><p>There are 5 filters — none, up, sub, average, and paeth. Each filter applies a certain operation to a row of bytes. We'll walk through a simple explanation of the first 3, but we won't talk about the <code>average</code> or <code>paeth</code> filters. They're pretty interesting, but the rest of this post will focus on the <code>sub</code> filter, so we don't need to worry about understanding how they work.<p>The <code>none</code> filter, as the name suggests, does not alter the bytes and just copies them as-is.<p>The <code>up</code> filter takes the pixel at position <code>n</code> and subtracts it by the pixel at position <code>n</code> in the row above it. For example, if we have two rows that look like this:<pre class=language-python data-lang=python style=background-color:#0f1419;color:#bfbab0;><code class=language-python data-lang=python><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>3</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>5</span><span>]
</span><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>3</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>5</span><span>]
</span></code></pre><p>After applying the <code>up</code> filter, we get this compressed result:<pre class=language-python data-lang=python style=background-color:#0f1419;color:#bfbab0;><code class=language-python data-lang=python><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>3</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>5</span><span>]
</span><span>[</span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>0</span><span>]
</span></code></pre><p>We consider the row before the first row to contain only zeros, so the first row is unchanged.<p>The <code>sub</code> filter takes the pixel at position <code>n</code> and subtracts it by the pixel in the same row at position <code>n - 1</code>. For example, if we have a row that looks like this:<pre class=language-python data-lang=python style=background-color:#0f1419;color:#bfbab0;><code class=language-python data-lang=python><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>3</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>5</span><span>]
</span></code></pre><p>If we apply the <code>sub</code> filter, we get this result:<pre class=language-python data-lang=python style=background-color:#0f1419;color:#bfbab0;><code class=language-python data-lang=python><span style=font-style:italic;color:#5c6773;># [1 - 0, 2 - 1, 3 - 2, 4 - 3, 5 - 4]
</span><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>1</span><span>]
</span></code></pre><p>The <code>sub</code> filter operates on individual channels. That is, the red channel of pixel <code>n</code> is subtracted by the red channel of pixel <code>n - 1</code>, the blue channel is subtracted by the prior pixel's blue channel, and so on. The calculation for finding the corresponding channel involves the pixel's <code>bpp</code>.<p>If we look at the <code>sub</code> filter as operating on individual bytes, we say that the algorithm is <code>filtered[n] = unfiltered[n] - unfiltered[n - bpp]</code>. Where <code>bpp</code> is calculated based on the color type and bit depth.<p>If this sounds a bit confusing, it should make a lot more sense when we start looking at an implementation in code.<p>To decode any of these filters, you just have to add to the filtered value, rather than subtract from the raw value.<h2 id=implementing-the-sub-filter>Implementing the <code>sub</code> Filter</h2><p>This is all just required background reading to understand what we're really interested in: optimizing the <code>sub</code> filter for 8-bit RGBA pixels. Although we introduced the filters by discussing how they're encoded, for the rest of this post we'll only be talking about how they're decoded.<p>Before moving on, however, I do want to note that the performance characteristics of filters inside the context of PNG decoders and PNG encoders are very different. This is because PNG decoders only have to apply a filter once per row, while a good encoder will likely try all filters for all rows. This can make PNG encoding somewhat slow, and also makes optimizations to individual filters more impactful. If we optimize a filter for PNG decoding, we only see wins for images that use that filter heavily. This may be an area I explore in the future, but for now my focus is primarily on decoding, as that's the operation most commonly performed on PNG files.<p>As promised, let's look at a simple code implementation of decoding the <code>sub</code> filter. All code examples going forward will be in rust.<pre class=language-rust data-lang=rust style=background-color:#0f1419;color:#bfbab0;><code class=language-rust data-lang=rust><span style=color:#ff7733;>pub fn </span><span style=color:#ffb454;>sub</span><span>(</span><span style=color:#f29718;>raw_row</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span>[</span><span style=color:#ff7733;>u8</span><span>], </span><span style=color:#f29718;>decoded_row</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>]) {
</span><span>    </span><span style=color:#ff7733;>for</span><span> i </span><span style=color:#f29668;>in </span><span style=color:#f29718;>0</span><span style=color:#f29668;>..</span><span style=color:#f29718;>BYTES_PER_PIXEL </span><span>{
</span><span>        decoded_row[i] </span><span style=color:#f29668;>=</span><span> raw_row[i]</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#ff7733;>for</span><span> i </span><span style=color:#f29668;>in </span><span style=color:#f29718;>BYTES_PER_PIXEL</span><span style=color:#f29668;>..</span><span>decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>len</span><span>() {
</span><span>        </span><span style=color:#ff7733;>let</span><span> left </span><span style=color:#f29668;>=</span><span> decoded_row[i </span><span style=color:#f29668;>- </span><span style=color:#f29718;>BYTES_PER_PIXEL</span><span>]</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        decoded_row[i] </span><span style=color:#f29668;>=</span><span> raw_row[i]</span><span style=color:#f29668;>.</span><span style=color:#f07178;>wrapping_add</span><span>(left)
</span><span>    }
</span><span>}
</span></code></pre><p>Bytes before the start of the row are 0, so we can just copy the first <code>bpp</code> bytes into the decoded row without doing any operations. For the next bytes, we add <code>decoded_row[i - bpp]</code> to the filtered byte.<p>Let's look at how LLVM does with this:<pre class=language-asm data-lang=asm style=background-color:#0f1419;color:#bfbab0;><code class=language-asm data-lang=asm><span style=color:#ffb454;>example::</span><span style=color:#ff7733;>sub</span><span style=color:#ffb454;>:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>push    </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>test    </span><span style=color:#f29718;>rsi</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>je      </span><span style=color:#ffb454;>.LBB2_1
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>test    </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>rcx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>je      </span><span style=color:#ffb454;>.LBB2_11
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdx</span><span>], </span><span style=color:#f29718;>al
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rsi</span><span>, </span><span style=color:#f29718;>1
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>je      </span><span style=color:#ffb454;>.LBB2_13
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>1
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>je      </span><span style=color:#ffb454;>.LBB2_15
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>1</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>1</span><span>], </span><span style=color:#f29718;>al
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rsi</span><span>, </span><span style=color:#f29718;>2
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>je      </span><span style=color:#ffb454;>.LBB2_17
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>2
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>je      </span><span style=color:#ffb454;>.LBB2_19
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>2</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>2</span><span>], </span><span style=color:#f29718;>al
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rsi</span><span>, </span><span style=color:#f29718;>3
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>je      </span><span style=color:#ffb454;>.LBB2_21
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>3
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>je      </span><span style=color:#ffb454;>.LBB2_23
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>3</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>3</span><span>], </span><span style=color:#f29718;>al
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jbe     </span><span style=color:#ffb454;>.LBB2_27
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>r8</span><span>, [</span><span style=color:#f29718;>rsi </span><span>- </span><span style=color:#f29718;>4</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>r8
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmovb   </span><span style=color:#f29718;>r8</span><span>, </span><span style=color:#f29718;>rcx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>rax</span><span>, [</span><span style=color:#f29718;>rcx </span><span>- </span><span style=color:#f29718;>5</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>r8</span><span>, </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmovae  </span><span style=color:#f29718;>r8</span><span>, </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>inc     </span><span style=color:#f29718;>r8
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>r10d</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>r8</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jbe     </span><span style=color:#ffb454;>.LBB2_4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>r9d</span><span>, </span><span style=color:#f29718;>r8d
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>r9d</span><span>, </span><span style=color:#f29718;>3
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmovne  </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>r9
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>r9</span><span>, </span><span style=color:#f29718;>r8
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>sub     </span><span style=color:#f29718;>r9</span><span>, </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>neg     </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>r10</span><span>, [</span><span style=color:#f29718;>r8 </span><span>+ </span><span style=color:#f29718;>rax</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>r10</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>xor     </span><span style=color:#f29718;>r8d</span><span>, </span><span style=color:#f29718;>r8d
</span><span style=color:#ffb454;>.LBB2_9:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f29718;>xmm0</span><span>, </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>r8 </span><span>+ </span><span style=color:#f29718;>4</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>r8</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vpaddb  </span><span style=color:#f29718;>xmm0</span><span>, </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>r8 </span><span>+ </span><span style=color:#f29718;>4</span><span>], </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>r8</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>r9</span><span>, </span><span style=color:#f29718;>r8
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jne     </span><span style=color:#ffb454;>.LBB2_9
</span><span style=color:#ffb454;>.LBB2_4:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>r8</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>neg     </span><span style=color:#f29718;>r8
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>r10</span><span>, -</span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>r9</span><span>, </span><span style=color:#f29718;>rcx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>neg     </span><span style=color:#f29718;>r9
</span><span style=color:#ffb454;>.LBB2_5:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>r10
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>je      </span><span style=color:#ffb454;>.LBB2_28
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>rax</span><span>, [</span><span style=color:#f29718;>r8 </span><span>+ </span><span style=color:#f29718;>r10</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rax</span><span>, -</span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>je      </span><span style=color:#ffb454;>.LBB2_7
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>r10</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>al</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>r10 </span><span>+ </span><span style=color:#f29718;>4</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>r10 </span><span>+ </span><span style=color:#f29718;>4</span><span>], </span><span style=color:#f29718;>al
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>rax</span><span>, [</span><span style=color:#f29718;>r9 </span><span>+ </span><span style=color:#f29718;>r10</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>inc     </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>inc     </span><span style=color:#f29718;>r10
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rax</span><span>, -</span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jne     </span><span style=color:#ffb454;>.LBB2_5
</span><span style=color:#ffb454;>.LBB2_27:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>pop     </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>ret
</span><span>
</span><span style=font-style:italic;color:#5c6773;>; ... panic handling code omitted
</span></code></pre><p>It does surprisingly well — though not perfect. It looks like our first loop is performed in serial and has bounds checks on every iteration. This is because we don't actually know that our input or output slice has at least <code>BYTES_PER_PIXEL</code> elements. If this were in the context of a real PNG decoder and this function got inlined, LLVM may be able to do a better job eliding bounds checks. In a real PNG decoder, a row length of 0 would imply the image data is empty and defiltering can be skipped altogether. The row length is guaranteed to be a multiple of <code>BYTES_PER_PIXEL</code>, and if it isn't, due to the image being malformed or truncated, we'd expect the PNG decoder to have errored out by this point. Going forward, our implementations of the <code>sub</code> filter will rely on these two assumptions.<p>The second loop is pretty interesting. It looks like LLVM is doing some magic to be able to vectorize it and perform the loads and additions <code>BYTES_PER_PIXEL</code> elements at a time. As we'll see later, this actually comes surprisingly close to our handwritten SIMD implementation.<p>Though, it does look like there's still a lot of code dedicated to handling bounds checks. Let's see the impact of removing them. For simplicity, we'll drop into unsafe to remove them. This code is just for experimenting, so we won't include any debug assertions that you'd expect in proper code using unsafe in this way.<pre class=language-rust data-lang=rust style=background-color:#0f1419;color:#bfbab0;><code class=language-rust data-lang=rust><span style=color:#ff7733;>pub unsafe fn </span><span style=color:#ffb454;>sub_no_bound_checks</span><span>(</span><span style=color:#f29718;>raw_row</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span>[</span><span style=color:#ff7733;>u8</span><span>], </span><span style=color:#f29718;>decoded_row</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>]) {
</span><span>    </span><span style=color:#ff7733;>for</span><span> i </span><span style=color:#f29668;>in </span><span style=color:#f29718;>0</span><span style=color:#f29668;>..</span><span style=color:#f29718;>BYTES_PER_PIXEL </span><span>{
</span><span>        </span><span style=color:#f29668;>*</span><span>decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked_mut</span><span>(i) </span><span style=color:#f29668;>= *</span><span>raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(i)</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#ff7733;>for</span><span> i </span><span style=color:#f29668;>in </span><span style=color:#f29718;>BYTES_PER_PIXEL</span><span style=color:#f29668;>..</span><span>decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>len</span><span>() {
</span><span>        </span><span style=color:#ff7733;>let</span><span> left </span><span style=color:#f29668;>= *</span><span>decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(i </span><span style=color:#f29668;>- </span><span style=color:#f29718;>BYTES_PER_PIXEL</span><span>)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        </span><span style=color:#f29668;>*</span><span>decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked_mut</span><span>(i) </span><span style=color:#f29668;>=</span><span> raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(i)</span><span style=color:#f29668;>.</span><span style=color:#f07178;>wrapping_add</span><span>(left)
</span><span>    }
</span><span>}
</span></code></pre><pre class=language-asm data-lang=asm style=background-color:#0f1419;color:#bfbab0;><code class=language-asm data-lang=asm><span style=color:#ffb454;>example::sub_no_bound_checks:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>push    </span><span style=color:#f29718;>rbx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdi</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdx</span><span>], </span><span style=color:#f29718;>eax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>5
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jb      </span><span style=color:#ffb454;>.LBB2_12
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>r8</span><span>, [</span><span style=color:#f29718;>rcx </span><span>- </span><span style=color:#f29718;>4</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>ebx</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>r8</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jb      </span><span style=color:#ffb454;>.LBB2_11
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>rbx</span><span>, </span><span style=color:#f29718;>r8
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f29718;>xmm0</span><span>, </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdx</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>rbx</span><span>, -</span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>rsi</span><span>, [</span><span style=color:#f29718;>rbx </span><span>- </span><span style=color:#f29718;>4</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>r10</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>shr     </span><span style=color:#f29718;>r10</span><span>, </span><span style=color:#f29718;>2
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>inc     </span><span style=color:#f29718;>r10
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>r9d</span><span>, </span><span style=color:#f29718;>r10d
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>r9d</span><span>, </span><span style=color:#f29718;>7
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rsi</span><span>, </span><span style=color:#f29718;>28
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB2_4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>xor     </span><span style=color:#f29718;>esi</span><span>, </span><span style=color:#f29718;>esi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jmp     </span><span style=color:#ffb454;>.LBB2_6
</span><span style=color:#ffb454;>.LBB2_4:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>r10</span><span>, -</span><span style=color:#f29718;>8
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>xor     </span><span style=color:#f29718;>esi</span><span>, </span><span style=color:#f29718;>esi
</span><span style=color:#ffb454;>.LBB2_5:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>4</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vpaddb  </span><span style=color:#f29718;>xmm0</span><span>, </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>4</span><span>], </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>8</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vpaddb  </span><span style=color:#f29718;>xmm0</span><span>, </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>8</span><span>], </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>12</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vpaddb  </span><span style=color:#f29718;>xmm0</span><span>, </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>12</span><span>], </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>16</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vpaddb  </span><span style=color:#f29718;>xmm0</span><span>, </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>16</span><span>], </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>20</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vpaddb  </span><span style=color:#f29718;>xmm0</span><span>, </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>20</span><span>], </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>24</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vpaddb  </span><span style=color:#f29718;>xmm0</span><span>, </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>24</span><span>], </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>28</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vpaddb  </span><span style=color:#f29718;>xmm0</span><span>, </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>28</span><span>], </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>32</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vpaddb  </span><span style=color:#f29718;>xmm0</span><span>, </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>32</span><span>], </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>rsi</span><span>, </span><span style=color:#f29718;>32
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>r10</span><span>, -</span><span style=color:#f29718;>8
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jne     </span><span style=color:#ffb454;>.LBB2_5
</span><span style=color:#ffb454;>.LBB2_6:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>test    </span><span style=color:#f29718;>r9</span><span>, </span><span style=color:#f29718;>r9
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>je      </span><span style=color:#ffb454;>.LBB2_9
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>r10</span><span>, [</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>rsi</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>r10</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>r11</span><span>, [</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rsi</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>r11</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>shl     </span><span style=color:#f29718;>r9</span><span>, </span><span style=color:#f29718;>2
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>xor     </span><span style=color:#f29718;>esi</span><span>, </span><span style=color:#f29718;>esi
</span><span style=color:#ffb454;>.LBB2_8:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>r11 </span><span>+ </span><span style=color:#f29718;>rsi</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vpaddb  </span><span style=color:#f29718;>xmm0</span><span>, </span><span style=color:#f29718;>xmm1</span><span>, </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>vmovd   </span><span style=color:#f07178;>dword ptr </span><span>[</span><span style=color:#f29718;>r10 </span><span>+ </span><span style=color:#f29718;>rsi</span><span>], </span><span style=color:#f29718;>xmm0
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>rsi</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>r9</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jne     </span><span style=color:#ffb454;>.LBB2_8
</span><span style=color:#ffb454;>.LBB2_9:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>r8</span><span>, </span><span style=color:#f29718;>rbx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>je      </span><span style=color:#ffb454;>.LBB2_12
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>rbx</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>.LBB2_11:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rbx</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>al</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>rbx </span><span>- </span><span style=color:#f29718;>4</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>rbx</span><span>], </span><span style=color:#f29718;>al
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>rax</span><span>, [</span><span style=color:#f29718;>rbx </span><span>+ </span><span style=color:#f29718;>1</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>rbx</span><span>, </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jne     </span><span style=color:#ffb454;>.LBB2_11
</span><span style=color:#ffb454;>.LBB2_12:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>pop     </span><span style=color:#f29718;>rbx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>ret
</span></code></pre><p>This does look a lot nicer. LLVM was able to autovectorize even more and it unrolled the second loop. Let's set up some benchmarks to see how big of an impact we had here. To benchmark, we'll use rust's stdlib benchmarking tools. We could use something like <a href=https://github.com/bheisler/criterion.rs>criterion</a>, but that's not necessary for what we're doing here. We <em>do</em> want good and scientific benchmarks as we start to iterate and explore new algorithms, but the stdlib solution is sufficient for that.<pre class=language-rust data-lang=rust style=background-color:#0f1419;color:#bfbab0;><code class=language-rust data-lang=rust><span style=color:#bfbab0cc;>#!</span><span>[</span><span style=color:#ffb454;>feature</span><span>(test)]
</span><span>
</span><span style=font-style:italic;color:#5c6773;>// ... our `sub` and `sub_no_bound_checks` implementations
</span><span>
</span><span style=color:#bfbab0cc;>#</span><span>[</span><span style=color:#ffb454;>cfg</span><span>(test)]
</span><span style=color:#ff7733;>mod </span><span style=color:#59c2ff;>bench </span><span>{
</span><span>    </span><span style=color:#ff7733;>use super</span><span style=color:#f29668;>::*</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>use </span><span>test</span><span style=color:#f29668;>::</span><span>Bencher</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    </span><span style=color:#ff7733;>const </span><span style=color:#f29718;>BUFFER_SIZE</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize </span><span style=color:#f29668;>= </span><span style=color:#f29718;>2_</span><span style=color:#ff7733;>usize</span><span style=color:#f29668;>.</span><span style=color:#f07178;>pow</span><span>(</span><span style=color:#f29718;>20</span><span>)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    </span><span style=color:#bfbab0cc;>#</span><span>[</span><span style=color:#ffb454;>bench</span><span>]
</span><span>    </span><span style=color:#ff7733;>fn </span><span style=color:#ffb454;>bench_sub_naive_scalar</span><span>(</span><span style=color:#f29718;>b</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> Bencher) {
</span><span>        </span><span style=color:#ff7733;>let</span><span> raw_row </span><span style=color:#f29668;>= </span><span>std</span><span style=color:#f29668;>::</span><span>hint</span><span style=color:#f29668;>::</span><span>black_box([</span><span style=color:#f29718;>10</span><span style=color:#bfbab0cc;>; </span><span style=color:#f29718;>BUFFER_SIZE</span><span>])</span><span style=color:#bfbab0cc;>;
</span><span>        </span><span style=color:#ff7733;>let mut</span><span> decoded_row </span><span style=color:#f29668;>= </span><span>std</span><span style=color:#f29668;>::</span><span>hint</span><span style=color:#f29668;>::</span><span>black_box([</span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>; </span><span style=color:#f29718;>BUFFER_SIZE</span><span>])</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        b</span><span style=color:#f29668;>.</span><span style=color:#f07178;>iter</span><span>(|| </span><span style=color:#f07178;>sub</span><span>(</span><span style=color:#f29668;>&</span><span>raw_row</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> decoded_row))</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        std</span><span style=color:#f29668;>::</span><span>hint</span><span style=color:#f29668;>::</span><span>black_box(decoded_row)</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#bfbab0cc;>#</span><span>[</span><span style=color:#ffb454;>bench</span><span>]
</span><span>    </span><span style=color:#ff7733;>fn </span><span style=color:#ffb454;>bench_sub_no_bound_checks</span><span>(</span><span style=color:#f29718;>b</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> Bencher) {
</span><span>        </span><span style=color:#ff7733;>let</span><span> raw_row </span><span style=color:#f29668;>= </span><span>std</span><span style=color:#f29668;>::</span><span>hint</span><span style=color:#f29668;>::</span><span>black_box([</span><span style=color:#f29718;>10</span><span style=color:#bfbab0cc;>; </span><span style=color:#f29718;>BUFFER_SIZE</span><span>])</span><span style=color:#bfbab0cc;>;
</span><span>        </span><span style=color:#ff7733;>let mut</span><span> decoded_row </span><span style=color:#f29668;>= </span><span>std</span><span style=color:#f29668;>::</span><span>hint</span><span style=color:#f29668;>::</span><span>black_box([</span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>; </span><span style=color:#f29718;>BUFFER_SIZE</span><span>])</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        b</span><span style=color:#f29668;>.</span><span style=color:#f07178;>iter</span><span>(|| </span><span style=color:#ff7733;>unsafe </span><span>{ </span><span style=color:#f07178;>sub_no_bound_checks</span><span>(</span><span style=color:#f29668;>&</span><span>raw_row</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> decoded_row) })</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        std</span><span style=color:#f29668;>::</span><span>hint</span><span style=color:#f29668;>::</span><span>black_box(decoded_row)</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>}
</span></code></pre><p>And now if we run our benchmarks using <code>cargo bench</code>, we get<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>running</span><span> 2 tests
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_naive_scalar    ... bench:      86,305 ns/iter (+/- 1,123)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_no_bound_checks ... bench:      86,289 ns/iter (+/- 2,324)
</span></code></pre><p>Although removing the bounds checks made our codegen look a lot nicer, it doesn't seem to actually improve our performance above noise. That's unfortunate. Let's see if we can do better.<p>The first goal is to try to get an idea of how close to the optimal solution we are. We can try comparing our filters to <code>memcpy</code>. We want to see how much overhead our subtraction is adding to the copying of bytes from <code>raw_row</code> to <code>decoded_row</code>.<p>We can add a benchmark that looks like this,<pre class=language-rust data-lang=rust style=background-color:#0f1419;color:#bfbab0;><code class=language-rust data-lang=rust><span style=color:#ff7733;>pub unsafe fn </span><span style=color:#ffb454;>baseline_memcpy</span><span>(</span><span style=color:#f29718;>raw_row</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span>[</span><span style=color:#ff7733;>u8</span><span>], </span><span style=color:#f29718;>decoded_row</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>]) {
</span><span>    decoded_row
</span><span>        </span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked_mut</span><span>(</span><span style=color:#f29718;>0</span><span style=color:#f29668;>..</span><span>raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>len</span><span>())
</span><span>        </span><span style=color:#f29668;>.</span><span style=color:#f07178;>copy_from_slice</span><span>(</span><span style=color:#f29668;>&*</span><span>raw_row)</span><span style=color:#bfbab0cc;>;
</span><span>}
</span><span>
</span><span style=color:#ff7733;>fn </span><span style=color:#ffb454;>bench_baseline_memcpy</span><span>(</span><span style=color:#f29718;>b</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> Bencher) {
</span><span>    </span><span style=color:#ff7733;>let</span><span> raw_row </span><span style=color:#f29668;>= </span><span>std</span><span style=color:#f29668;>::</span><span>hint</span><span style=color:#f29668;>::</span><span>black_box([</span><span style=color:#f29718;>10</span><span style=color:#bfbab0cc;>; </span><span style=color:#f29718;>BUFFER_SIZE</span><span>])</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> decoded_row </span><span style=color:#f29668;>= </span><span>std</span><span style=color:#f29668;>::</span><span>hint</span><span style=color:#f29668;>::</span><span>black_box([</span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>; </span><span style=color:#f29718;>BUFFER_SIZE</span><span>])</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    b</span><span style=color:#f29668;>.</span><span style=color:#f07178;>iter</span><span>(|| </span><span style=color:#ff7733;>unsafe </span><span>{ </span><span style=color:#f07178;>baseline_memcpy</span><span>(</span><span style=color:#f29668;>&</span><span>raw_row</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> decoded_row) })</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    std</span><span style=color:#f29668;>::</span><span>hint</span><span style=color:#f29668;>::</span><span>black_box(decoded_row)</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>And to double check that <code>baseline_memcpy</code> gets optimized how we expect,<pre class=language-asm data-lang=asm style=background-color:#0f1419;color:#bfbab0;><code class=language-asm data-lang=asm><span style=color:#ffb454;>example::baseline_memcpy:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rdx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>rdx</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>rsi</span><span>, </span><span style=color:#f29718;>rdi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>rdi</span><span>, </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jmp     </span><span style=color:#f07178;>qword ptr </span><span>[</span><span style=color:#f29718;>rip </span><span>+ </span><span style=color:#ffb454;>memcpy@GOTPCREL</span><span>]
</span></code></pre><p>Great. Now let's compare it to our <code>sub</code> implementations.<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>running</span><span> 3 tests
</span><span style=color:#ffb454;>test</span><span> tests::bench_baseline_memcpy     ... bench:      61,875 ns/iter (+/- 3,949)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_naive_scalar    ... bench:      86,731 ns/iter (+/- 1,833)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_no_bound_checks ... bench:      86,584 ns/iter (+/- 1,374)
</span></code></pre><p>Our initial implementations don't actually seem to be <em>that</em> bad. But there's probably a lot of room for improvement here.<h2 id=current-state-of-the-art>Current State of the Art</h2><p><code>libpng</code> has had optimized filter implementations using explicit SIMD for <a href=https://github.com/glennrp/libpng/pull/88>close to a decade</a>.<p>The optimization that they make is based around <code>bpp</code>.<p>It's difficult to decode the PNG filters in parallel. At first glance, it looks like there's a pretty strict data dependency on previous iterations. If we look at an example calculation, this becomes pretty clear. For simplicity in our example, we'll say <code>bpp</code> is 1. When we implement things in code, we'll usually default to a <code>bpp</code> of 4.<p>We'll start with the filtered array <code>[1, 2, 3]</code> and walk through defiltering it.<pre class=language-python data-lang=python style=background-color:#0f1419;color:#bfbab0;><code class=language-python data-lang=python><span>filtered </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>3</span><span>]
</span><span>defiltered </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>0</span><span>]
</span><span>
</span><span style=font-style:italic;color:#5c6773;># defiltered = [1, 0, 0]
</span><span>defiltered[</span><span style=color:#f29718;>0</span><span>] </span><span style=color:#f29668;>= </span><span>filtered[</span><span style=color:#f29718;>0</span><span>]
</span><span>
</span><span style=font-style:italic;color:#5c6773;># defiltered = [1, 3, 0]
</span><span>defiltered[</span><span style=color:#f29718;>1</span><span>] </span><span style=color:#f29668;>= </span><span>defiltered[</span><span style=color:#f29718;>0</span><span>] </span><span style=color:#f29668;>+ </span><span>filtered[</span><span style=color:#f29718;>1</span><span>]
</span><span>
</span><span style=font-style:italic;color:#5c6773;># defiltered = [1, 3, 6]
</span><span>defiltered[</span><span style=color:#f29718;>2</span><span>] </span><span style=color:#f29668;>= </span><span>defiltered[</span><span style=color:#f29718;>1</span><span>] </span><span style=color:#f29668;>+ </span><span>filtered[</span><span style=color:#f29718;>2</span><span>]
</span></code></pre><p>The last calculation depends on the results of the second-to-last calculation. How can we work around this?<p><code>libpng</code>'s optimization doesn't really try to — it still does a lot of things in serial. But when the <code>bpp</code> is greater than 1, it can operate on <code>bpp</code> bytes per iteration rather than going byte-by-byte. This ends up being pretty fast — for a <code>bpp</code> of 4, you're operating on 4x the number of bytes.<p>Let's look at how this implementation works in practice. We're going to port <a href=https://github.com/glennrp/libpng/blob/f135775ad4e5d4408d2e12ffcc71bb36e6b48551/intel/filter_sse2_intrinsics.c#L85>libpng's 4 bpp implementation</a> to rust:<pre class=language-rust data-lang=rust style=background-color:#0f1419;color:#bfbab0;><code class=language-rust data-lang=rust><span style=color:#ff7733;>unsafe fn </span><span style=color:#ffb454;>load4</span><span>(</span><span style=color:#f29718;>x</span><span style=color:#bfbab0cc;>:</span><span> [</span><span style=color:#ff7733;>u8</span><span>; 4]) </span><span style=color:#bfbab0cc;>-></span><span> __m128i {
</span><span>    </span><span style=color:#ff7733;>let</span><span> tmp </span><span style=color:#f29668;>= </span><span style=color:#ff7733;>i32</span><span style=color:#f29668;>::</span><span>from_le_bytes(</span><span style=color:#f29668;>*</span><span>x)</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#f07178;>_mm_cvtsi32_si128</span><span>(tmp)
</span><span>}
</span><span>
</span><span style=color:#ff7733;>unsafe fn </span><span style=color:#ffb454;>store4</span><span>(</span><span style=color:#f29718;>x</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>; 4], </span><span style=color:#f29718;>v</span><span style=color:#bfbab0cc;>:</span><span> __m128i) {
</span><span>    </span><span style=color:#ff7733;>let</span><span> tmp </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm_cvtsi128_si32</span><span>(v)</span><span style=color:#bfbab0cc;>;
</span><span>    x</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked_mut</span><span>(</span><span style=color:#f29668;>..</span><span style=color:#f29718;>4</span><span>)</span><span style=color:#f29668;>.</span><span style=color:#f07178;>copy_from_slice</span><span>(</span><span style=color:#f29668;>&</span><span>tmp</span><span style=color:#f29668;>.</span><span style=color:#f07178;>to_le_bytes</span><span>())</span><span style=color:#bfbab0cc;>;
</span><span>}
</span><span>
</span><span style=color:#ff7733;>pub unsafe fn </span><span style=color:#ffb454;>sub_sse2</span><span>(</span><span style=color:#f29718;>raw</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span>[</span><span style=color:#ff7733;>u8</span><span>], </span><span style=color:#f29718;>current</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>]) {
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> a</span><span style=color:#bfbab0cc;>:</span><span> __m128i</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> d </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm_setzero_si128</span><span>()</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> rb </span><span style=color:#f29668;>=</span><span> raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>len</span><span>() </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> idx </span><span style=color:#f29668;>= </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    </span><span style=color:#ff7733;>while</span><span> rb </span><span style=color:#f29668;>> </span><span style=color:#f29718;>4 </span><span>{
</span><span>        a </span><span style=color:#f29668;>=</span><span> d</span><span style=color:#bfbab0cc;>;
</span><span>        d </span><span style=color:#f29668;>= </span><span style=color:#f07178;>load4</span><span>([
</span><span>            </span><span style=color:#f29668;>*</span><span>raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(idx)</span><span style=color:#bfbab0cc;>,
</span><span>            </span><span style=color:#f29668;>*</span><span>raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(idx </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>)</span><span style=color:#bfbab0cc;>,
</span><span>            </span><span style=color:#f29668;>*</span><span>raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(idx </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>)</span><span style=color:#bfbab0cc;>,
</span><span>            </span><span style=color:#f29668;>*</span><span>raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(idx </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>)</span><span style=color:#bfbab0cc;>,
</span><span>        ])</span><span style=color:#bfbab0cc;>;
</span><span>        d </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm_add_epi8</span><span>(d</span><span style=color:#bfbab0cc;>,</span><span> a)</span><span style=color:#bfbab0cc;>;
</span><span>        </span><span style=color:#f07178;>store4</span><span>(</span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked_mut</span><span>(idx</span><span style=color:#f29668;>..</span><span>)</span><span style=color:#bfbab0cc;>,</span><span> d)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        idx </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>        rb </span><span style=color:#f29668;>-= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>}
</span></code></pre><p>So instead of loading, adding, and storing one byte at a time, we can operate on 4 bytes at a time. Let's benchmark this implementation to see how it performs.<pre class=language-rust data-lang=rust style=background-color:#0f1419;color:#bfbab0;><code class=language-rust data-lang=rust><span style=color:#bfbab0cc;>#</span><span>[</span><span style=color:#ffb454;>bench</span><span>]
</span><span style=color:#ff7733;>fn </span><span style=color:#ffb454;>bench_sub_sse2</span><span>(</span><span style=color:#f29718;>b</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> Bencher) {
</span><span>    </span><span style=color:#ff7733;>let</span><span> raw_row </span><span style=color:#f29668;>= </span><span>std</span><span style=color:#f29668;>::</span><span>hint</span><span style=color:#f29668;>::</span><span>black_box([</span><span style=color:#f29718;>10</span><span style=color:#bfbab0cc;>; </span><span style=color:#f29718;>BUFFER_SIZE</span><span>])</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> decoded_row </span><span style=color:#f29668;>= </span><span>std</span><span style=color:#f29668;>::</span><span>hint</span><span style=color:#f29668;>::</span><span>black_box([</span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>; </span><span style=color:#f29718;>BUFFER_SIZE</span><span>])</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    b</span><span style=color:#f29668;>.</span><span style=color:#f07178;>iter</span><span>(|| </span><span style=color:#ff7733;>unsafe </span><span>{ </span><span style=color:#f07178;>sub_sse2</span><span>(</span><span style=color:#f29668;>&*</span><span>raw_row</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut </span><span style=color:#f29668;>*</span><span>decoded_row) })</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    std</span><span style=color:#f29668;>::</span><span>hint</span><span style=color:#f29668;>::</span><span>black_box(decoded_row)</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>When we benchmark this time, we want to make use of SIMD intrinsics. To force LLVM to compile them optimally we'll have to configure <code>target-cpu=native</code>. If we don't do this, our intrinsics will be compiled suboptimally and we actually tend to get slower code than the scalar version, at least on my Linux machine.<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span>RUSTFLAGS</span><span style=color:#f29668;>=</span><span style=color:#c2d94c;>'-Ctarget-cpu=native' </span><span style=color:#ffb454;>cargo</span><span> bench
</span></code></pre><pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>running</span><span> 4 tests
</span><span style=color:#ffb454;>test</span><span> tests::bench_baseline_memcpy     ... bench:      62,844 ns/iter (+/- 3,258)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_naive_scalar    ... bench:      86,798 ns/iter (+/- 1,502)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_no_bound_checks ... bench:      86,719 ns/iter (+/- 2,057)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_sse2            ... bench:      86,573 ns/iter (+/- 1,004)
</span></code></pre><p>Pretty much no improvement. We saw previously that LLVM was able to autovectorize our loop to operate on 4 bytes at a time already, so this is likely the explanation for why our explicit SIMD implementation isn't too much faster. It could be that we missed something in porting the C code, but that seems unlikely here. In general, it doesn't seem that we can get a massive win if we're stuck operating on <code>bpp</code> bytes at a time.<h2 id=trying-a-different-algorithm>Trying a Different Algorithm</h2><p>About a year ago, I had the idea to try solving the PNG filters using AVX and AVX2. AVX enables us to operate on 32 bytes at a time, compared to our current implementation that operates on at most 4 bytes at a time. If we're able to use AVX registers and instructions, we'd be able to operate on 8x the number of bytes as existing implementations of the filters.<p>After playing around with the problem for a while, I realized<sup class=footnote-reference><a href=#1>1</a></sup> that decoding the <code>sub</code> filter can be pretty trivially reduced down to a pretty well-studied problem called <a href=https://en.wikipedia.org/wiki/Prefix_sum>prefix sum</a>. Prefix sum happens to be extremely easy to compute in parallel, which makes our problem a lot simpler.<p>The idea behind parallel prefix sum is that you can trivially subdivide the problem and then combine the results of the separate executions. Let's take a simple example:<p>Given an array <code>[1, 2, 3, 4]</code>, the serial solution would be to just loop over the entire array. In a parallel version, we can split this array into <code>[1, 2]</code> and <code>[3, 4]</code> and compute the prefix sums separately. Then, we can take the last element of the first array and add it to each element in the second array. We'll call this the accumulate step.<p>So after executing the prefix sum step, we end up with the two arrays <code>[1, 3]</code> and <code>[3, 7]</code>. Then we apply the accumulate step and end up with two arrays <code>[1, 3]</code> and <code>[6, 10]</code>. Combining them, we get <code>[1, 3, 6, 10]</code> which is the correct prefix sum result we're looking for.<p>This sounds like we're doing more work — and we are. But these kinds of operations are really fast in SIMD, so the actual number of instructions per byte is significantly less than in the scalar solution.<p><a href=https://en.algorithmica.org/hpc/algorithms/prefix/>Algorithmica has a pretty good explanation of vectorized prefix sum</a> that goes quite a bit deeper than we need to for this problem, but is a great read if you're interested in learning more.<p>We'll actually end up with something that looks very similar to algorithmica's first vectorized example. The only difference is that the algorithm presented by algorithmica operates on 32-bit integers in sequence, while we want to operate on 8-bit bytes offset by <code>bpp</code>. When <code>bpp</code> is 4, this looks strikingly similar to just adding 32-bit integers.<p>For the accumulate step, we're going to use <code>_mm256_extract_epi32</code>. I wasn't able to port their accumulate implementation very well, but I'd assume it compiles down to roughly the same thing.<p>Here's our implementation of the <code>sub</code> filter using the full width of AVX registers:<pre class=language-rust data-lang=rust style=background-color:#0f1419;color:#bfbab0;><code class=language-rust data-lang=rust><span style=color:#ff7733;>pub unsafe fn </span><span style=color:#ffb454;>sub_avx</span><span>(</span><span style=color:#f29718;>raw_row</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span>[</span><span style=color:#ff7733;>u8</span><span>], </span><span style=color:#f29718;>decoded_row</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>]) {
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> last </span><span style=color:#f29668;>= </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> x</span><span style=color:#bfbab0cc;>:</span><span> __m256i</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    </span><span style=color:#ff7733;>let</span><span> len </span><span style=color:#f29668;>=</span><span> raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>len</span><span>()</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> i </span><span style=color:#f29668;>= </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    </span><span style=font-style:italic;color:#5c6773;>// we ensure the length in our SIMD loop is divisible by 32
</span><span>    </span><span style=color:#ff7733;>let</span><span> offset </span><span style=color:#f29668;>=</span><span> len </span><span style=color:#f29668;>% </span><span style=color:#f29718;>32</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>if</span><span> offset </span><span style=color:#f29668;>!= </span><span style=color:#f29718;>0 </span><span>{
</span><span>        </span><span style=color:#f07178;>sub_sse2</span><span>(raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(</span><span style=color:#f29668;>..</span><span>offset)</span><span style=color:#bfbab0cc;>,</span><span> decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked_mut</span><span>(</span><span style=color:#f29668;>..</span><span>offset))</span><span style=color:#bfbab0cc;>;
</span><span>        last </span><span style=color:#f29668;>= </span><span style=color:#ff7733;>i32</span><span style=color:#f29668;>::</span><span>from_be_bytes([
</span><span>            </span><span style=color:#f29668;>*</span><span>decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(offset </span><span style=color:#f29668;>- </span><span style=color:#f29718;>1</span><span>)</span><span style=color:#bfbab0cc;>,
</span><span>            </span><span style=color:#f29668;>*</span><span>decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(offset </span><span style=color:#f29668;>- </span><span style=color:#f29718;>2</span><span>)</span><span style=color:#bfbab0cc;>,
</span><span>            </span><span style=color:#f29668;>*</span><span>decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(offset </span><span style=color:#f29668;>- </span><span style=color:#f29718;>3</span><span>)</span><span style=color:#bfbab0cc;>,
</span><span>            </span><span style=color:#f29668;>*</span><span>decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(offset </span><span style=color:#f29668;>- </span><span style=color:#f29718;>4</span><span>)</span><span style=color:#bfbab0cc;>,
</span><span>        ])</span><span style=color:#bfbab0cc;>;
</span><span>        i </span><span style=color:#f29668;>=</span><span> offset</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#ff7733;>while</span><span> len </span><span style=color:#f29668;>!=</span><span> i {
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// load 32 bytes from input array
</span><span>        x </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm256_loadu_si256</span><span>(raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(i) </span><span style=color:#f29668;>as </span><span style=color:#ff7733;>*const </span><span style=color:#f29668;>_ as </span><span style=color:#ff7733;>*const</span><span> __m256i)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// do prefix sum
</span><span>        x </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm256_add_epi8</span><span>(_mm256_slli_si256</span><span style=color:#f29668;>::</span><span>&LT4>(x)</span><span style=color:#bfbab0cc;>,</span><span> x)</span><span style=color:#bfbab0cc;>;
</span><span>        x </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm256_add_epi8</span><span>(_mm256_slli_si256</span><span style=color:#f29668;>::</span><span><</span><span style=color:#ff3333;>{ </span><span style=color:#f29718;>2 </span><span style=color:#f29668;>* </span><span style=color:#f29718;>4</span><span> }</span><span style=color:#f29668;>></span><span>(x)</span><span style=color:#bfbab0cc;>,</span><span> x)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// accumulate for first 16 bytes
</span><span>        </span><span style=color:#ff7733;>let</span><span> b </span><span style=color:#f29668;>= </span><span>_mm256_extract_epi32</span><span style=color:#f29668;>::</span><span>&LT3>(x)</span><span style=color:#bfbab0cc;>;
</span><span>        x </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm256_add_epi8</span><span>(</span><span style=color:#f07178;>_mm256_set_epi32</span><span>(b</span><span style=color:#bfbab0cc;>,</span><span> b</span><span style=color:#bfbab0cc;>,</span><span> b</span><span style=color:#bfbab0cc;>,</span><span> b</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>0</span><span>)</span><span style=color:#bfbab0cc;>,</span><span> x)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// accumulate for previous chunk of 16 bytes
</span><span>        x </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm256_add_epi8</span><span>(</span><span style=color:#f07178;>_mm256_set1_epi32</span><span>(last)</span><span style=color:#bfbab0cc;>,</span><span> x)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// extract last 4 bytes to be used in next iteration
</span><span>        last </span><span style=color:#f29668;>= </span><span>_mm256_extract_epi32</span><span style=color:#f29668;>::</span><span>&LT7>(x)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// write 32 bytes to out array
</span><span>        </span><span style=color:#f07178;>_mm256_storeu_si256</span><span>(decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked_mut</span><span>(i) </span><span style=color:#f29668;>as </span><span style=color:#ff7733;>*mut </span><span style=color:#f29668;>_ as </span><span style=color:#ff7733;>*mut</span><span> __m256i</span><span style=color:#bfbab0cc;>,</span><span> x)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        i </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>32</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>}
</span></code></pre><p>We can reuse our SSE implementation for our remainder loop at the start. How does this perform?<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span>RUSTFLAGS</span><span style=color:#f29668;>=</span><span style=color:#c2d94c;>'-Ctarget-cpu=native' </span><span style=color:#ffb454;>cargo</span><span> bench
</span></code></pre><pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>running</span><span> 5 tests
</span><span style=color:#ffb454;>test</span><span> tests::bench_baseline_memcpy     ... bench:      61,624 ns/iter (+/- 3,384)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_avx             ... bench:      82,168 ns/iter (+/- 3,754)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_naive_scalar    ... bench:      86,713 ns/iter (+/- 3,411)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_no_bound_checks ... bench:      86,567 ns/iter (+/- 1,432)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_sse2            ... bench:      86,422 ns/iter (+/- 3,934)
</span></code></pre><p>We get something that's a bit faster. It isn't too much above noise, but in my testing it does appear to run consistently ~5% faster. That's not nothing, but it's definitely a much smaller win than we'd expect from operating on 8x the number of bytes at a time. It's likely that although we're now able to operate on a larger number of bytes at a time, our wins are being consumed by the extra processing we're now doing to perform prefix sum.<p>This is roughly where I left things for about a year. I came back to this problem every once in a while after being inspired by blog posts, reading code, or learning about interesting applications of x86 SIMD intrinsics, but in general I wasn't able to improve on this problem too much.<p>The particularly slow part is <code>_mm256_extract_epi32</code>, especially the second call with a value of <code>7</code>. For values above 3, this intrinsic will compile down to multiple expensive instructions. If we remove this intrinsic, we approach the speed of <code>memcpy</code>. However, we can't really remove this intrinsic, since it's necessary for the accumulate step.<p>Last week, as part of a larger blog post investigating the performance of PNG decoders, I revisited this problem. For the sake of completion, I was interested to see how a similar algorithm would perform if we used SSE registers instead.<p>The initial implementation looks like this:<pre class=language-rust data-lang=rust style=background-color:#0f1419;color:#bfbab0;><code class=language-rust data-lang=rust><span style=color:#ff7733;>pub unsafe fn </span><span style=color:#ffb454;>sub_sse_prefix_sum</span><span>(</span><span style=color:#f29718;>raw_row</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span>[</span><span style=color:#ff7733;>u8</span><span>], </span><span style=color:#f29718;>decoded_row</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>]) {
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> last </span><span style=color:#f29668;>= </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> x</span><span style=color:#bfbab0cc;>:</span><span> __m128i</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    </span><span style=color:#ff7733;>let</span><span> len </span><span style=color:#f29668;>=</span><span> raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>len</span><span>()</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> i </span><span style=color:#f29668;>= </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    </span><span style=color:#ff7733;>let</span><span> offset </span><span style=color:#f29668;>=</span><span> len </span><span style=color:#f29668;>% </span><span style=color:#f29718;>16</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>if</span><span> offset </span><span style=color:#f29668;>!= </span><span style=color:#f29718;>0 </span><span>{
</span><span>        </span><span style=color:#f07178;>sub_sse2</span><span>(raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(</span><span style=color:#f29668;>..</span><span>offset)</span><span style=color:#bfbab0cc;>,</span><span> decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked_mut</span><span>(</span><span style=color:#f29668;>..</span><span>offset))</span><span style=color:#bfbab0cc;>;
</span><span>        last </span><span style=color:#f29668;>= </span><span style=color:#ff7733;>i32</span><span style=color:#f29668;>::</span><span>from_be_bytes([
</span><span>            </span><span style=color:#f29668;>*</span><span>decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(offset </span><span style=color:#f29668;>- </span><span style=color:#f29718;>1</span><span>)</span><span style=color:#bfbab0cc;>,
</span><span>            </span><span style=color:#f29668;>*</span><span>decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(offset </span><span style=color:#f29668;>- </span><span style=color:#f29718;>2</span><span>)</span><span style=color:#bfbab0cc;>,
</span><span>            </span><span style=color:#f29668;>*</span><span>decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(offset </span><span style=color:#f29668;>- </span><span style=color:#f29718;>3</span><span>)</span><span style=color:#bfbab0cc;>,
</span><span>            </span><span style=color:#f29668;>*</span><span>decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(offset </span><span style=color:#f29668;>- </span><span style=color:#f29718;>4</span><span>)</span><span style=color:#bfbab0cc;>,
</span><span>        ])</span><span style=color:#bfbab0cc;>;
</span><span>        i </span><span style=color:#f29668;>=</span><span> offset</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#ff7733;>while</span><span> len </span><span style=color:#f29668;>!=</span><span> i {
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// load 16 bytes from array
</span><span>        x </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm_loadu_si128</span><span>(raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(i) </span><span style=color:#f29668;>as </span><span style=color:#ff7733;>*const </span><span style=color:#f29668;>_ as </span><span style=color:#ff7733;>*const</span><span> __m128i)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// do prefix sum
</span><span>        x </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm_add_epi8</span><span>(_mm_slli_si128</span><span style=color:#f29668;>::</span><span>&LT4>(x)</span><span style=color:#bfbab0cc;>,</span><span> x)</span><span style=color:#bfbab0cc;>;
</span><span>        x </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm_add_epi8</span><span>(_mm_slli_si128</span><span style=color:#f29668;>::</span><span><</span><span style=color:#ff3333;>{ </span><span style=color:#f29718;>2 </span><span style=color:#f29668;>* </span><span style=color:#f29718;>4</span><span> }</span><span style=color:#f29668;>></span><span>(x)</span><span style=color:#bfbab0cc;>,</span><span> x)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// accumulate for previous chunk of 16 bytes
</span><span>        x </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm_add_epi8</span><span>(x</span><span style=color:#bfbab0cc;>, </span><span style=color:#f07178;>_mm_set1_epi32</span><span>(last))</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        last </span><span style=color:#f29668;>= </span><span>_mm_extract_epi32</span><span style=color:#f29668;>::</span><span>&LT3>(x)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// write 16 bytes to out array
</span><span>        </span><span style=color:#f07178;>_mm_storeu_si128</span><span>(decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked_mut</span><span>(i) </span><span style=color:#f29668;>as </span><span style=color:#ff7733;>*mut </span><span style=color:#f29668;>_ as </span><span style=color:#ff7733;>*mut</span><span> __m128i</span><span style=color:#bfbab0cc;>,</span><span> x)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        i </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>16</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>}
</span></code></pre><p>This is pretty much the same as our AVX implementation, except now we operate on 16 bytes at a time. Let's see how this performs:<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>running</span><span> 6 tests
</span><span style=color:#ffb454;>test</span><span> tests::bench_baseline_memcpy     ... bench:      61,482 ns/iter (+/- 10,144)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_avx             ... bench:      82,137 ns/iter (+/- 623)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_naive_scalar    ... bench:      86,471 ns/iter (+/- 2,308)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_no_bound_checks ... bench:      86,571 ns/iter (+/- 9,310)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_sse2            ... bench:      86,146 ns/iter (+/- 2,569)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_sse_prefix_sum  ... bench:     113,024 ns/iter (+/- 1,683)
</span></code></pre><p>It's quite a bit slower. I guess that's to be expected. The AVX implementation operates on 2x the number of bytes and only gets a 5% speedup. If we only use SSE registers, we don't see any gains.<p>But, something interesting about using SSE registers is that we can actually avoid the extract by doing a bitshift and a broadcast. Let's look at an implementation using this,<pre class=language-rust data-lang=rust style=background-color:#0f1419;color:#bfbab0;><code class=language-rust data-lang=rust><span style=color:#ff7733;>pub unsafe fn </span><span style=color:#ffb454;>sub_sse_prefix_sum_no_extract</span><span>(</span><span style=color:#f29718;>raw_row</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span>[</span><span style=color:#ff7733;>u8</span><span>], </span><span style=color:#f29718;>decoded_row</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>]) {
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> last </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm_setzero_si128</span><span>()</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> x</span><span style=color:#bfbab0cc;>:</span><span> __m128i</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    </span><span style=color:#ff7733;>let</span><span> len </span><span style=color:#f29668;>=</span><span> raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>len</span><span>()</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> i </span><span style=color:#f29668;>= </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    </span><span style=color:#ff7733;>let</span><span> offset </span><span style=color:#f29668;>=</span><span> len </span><span style=color:#f29668;>% </span><span style=color:#f29718;>16</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>if</span><span> offset </span><span style=color:#f29668;>!= </span><span style=color:#f29718;>0 </span><span>{
</span><span>        </span><span style=color:#f07178;>sub_sse2</span><span>(raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(</span><span style=color:#f29668;>..</span><span>offset)</span><span style=color:#bfbab0cc;>,</span><span> decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked_mut</span><span>(</span><span style=color:#f29668;>..</span><span>offset))</span><span style=color:#bfbab0cc;>;
</span><span>        last </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm_castps_si128</span><span>(</span><span style=color:#f07178;>_mm_broadcast_ss</span><span>(</span><span style=color:#f29668;>&*</span><span>(decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(offset </span><span style=color:#f29668;>- </span><span style=color:#f29718;>4</span><span>) </span><span style=color:#f29668;>as </span><span style=color:#ff7733;>*const </span><span style=color:#f29668;>_ as </span><span style=color:#ff7733;>*const f32</span><span>)))</span><span style=color:#bfbab0cc;>;
</span><span>        i </span><span style=color:#f29668;>=</span><span> offset</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#ff7733;>while</span><span> len </span><span style=color:#f29668;>!=</span><span> i {
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// load 16 bytes from array
</span><span>        x </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm_loadu_si128</span><span>(raw_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(i) </span><span style=color:#f29668;>as </span><span style=color:#ff7733;>*const </span><span style=color:#f29668;>_ as </span><span style=color:#ff7733;>*const</span><span> __m128i)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// do prefix sum
</span><span>        x </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm_add_epi8</span><span>(_mm_slli_si128</span><span style=color:#f29668;>::</span><span>&LT4>(x)</span><span style=color:#bfbab0cc;>,</span><span> x)</span><span style=color:#bfbab0cc;>;
</span><span>        x </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm_add_epi8</span><span>(_mm_slli_si128</span><span style=color:#f29668;>::</span><span><</span><span style=color:#ff3333;>{ </span><span style=color:#f29718;>2 </span><span style=color:#f29668;>* </span><span style=color:#f29718;>4</span><span> }</span><span style=color:#f29668;>></span><span>(x)</span><span style=color:#bfbab0cc;>,</span><span> x)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// accumulate for previous chunk of 16 bytes
</span><span>        x </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm_add_epi8</span><span>(x</span><span style=color:#bfbab0cc;>,</span><span> last)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// shift right by 12 bytes and then broadcast the lower 4 bytes
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// to the rest of the register
</span><span>        last </span><span style=color:#f29668;>= </span><span>_mm_srli_si128</span><span style=color:#f29668;>::</span><span>&LT12>(x)</span><span style=color:#bfbab0cc;>;
</span><span>        last </span><span style=color:#f29668;>= </span><span style=color:#f07178;>_mm_broadcastd_epi32</span><span>(last)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        </span><span style=color:#f07178;>_mm_storeu_si128</span><span>(decoded_row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked_mut</span><span>(i) </span><span style=color:#f29668;>as </span><span style=color:#ff7733;>*mut </span><span style=color:#f29668;>_ as </span><span style=color:#ff7733;>*mut</span><span> __m128i</span><span style=color:#bfbab0cc;>,</span><span> x)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>        i </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>16</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>}
</span></code></pre><p>Running the benchmarks:<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>running</span><span> 7 tests
</span><span style=color:#ffb454;>test</span><span> tests::bench_baseline_memcpy               ... bench:      62,683 ns/iter (+/- 18,025)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_avx                       ... bench:      82,232 ns/iter (+/- 9,210)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_naive_scalar              ... bench:      86,680 ns/iter (+/- 2,137)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_no_bound_checks           ... bench:      86,756 ns/iter (+/- 1,310)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_sse2                      ... bench:      86,519 ns/iter (+/- 2,527)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_sse_prefix_sum            ... bench:     112,770 ns/iter (+/- 4,366)
</span><span style=color:#ffb454;>test</span><span> tests::bench_sub_sse_prefix_sum_no_extract ... bench:      69,864 ns/iter (+/- 1,696)
</span></code></pre><p>It's a lot faster! We're approaching the speed of <code>memcpy</code>. With this new algorithm, we can go ~25% faster than a naive approach operating on only 4 bytes at a time. It seems hard to improve on this further — at some point we'll be bound by memory. As a proof of concept for this algorithm, I think this works quite well. It may be possible to improve on this by making better use of AVX intrinsics, but for right now it's likely not worth the effort to optimize this further.<h2 id=impact-of-this-research>Impact of this research</h2><p>The goal up to this point has largely been to demonstrate that this algorithm can improve the performance of PNG decoding. The work demonstrated here is a proof-of-concept and doesn't contain a production-ready implementation.<p>The <code>sub</code> filter is just a small part of PNG decoding. Although we managed to speed it up by 25% for inputs of this size, this doesn't correlate to a 25% improvement of PNG decoding. The exact improvement here is a bit hard to calculate as it depends heavily on the input — the dimensions of the PNG, DEFLATE's compression level, the distribution of filters, etc. In general I wouldn't expect this to be too large of a win in total decode time, but it may become meaningful if you're trying to write the fastest theoretical PNG decoder (this is foreshadowing).<p>I think it may be possible to apply similar ideas to the <code>avg</code> and <code>paeth</code> filters, but I haven't yet come up with a performant solution for them. One particularly painful issue with the <code>avg</code> filter is that the average is taken with 9 bits of precision, rather than 8, and then truncated — so it's not sufficient to just do a bitshift in order to divide by two. Future research here may involve the <code>VPAVGB</code> instruction.<p>I haven't yet investigated the <code>paeth</code> filter, so I'm not sure how difficult such a solution for this filter would be. At first glance it appears quite a bit more challenging than the other filters, but there may be a clever solution hiding somewhere.<div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>The intuition for this may be a bit challenging to come up with if you're not already familiar with prefix sum and its properties. I believe this particular idea came to me by just staring at an example execution for a bit.</div></section></article></main></div><script>window.addEventListener('load', function () {
            for (const ref of document.getElementsByClassName('footnote-reference')) {
                const hash = ref.children[0].hash.substring(1);
                const refhash = 'ref:' + hash;
                ref.id = refhash;
            }

            for (const footnote of document.getElementsByClassName('footnote-definition')) {
                const hash = footnote.id;
                const refhash = 'ref:' + hash;
                const backlink = document.createElement('a');
                backlink.href = '#' + refhash;
                backlink.className = 'footnote-backlink';
                backlink.innerText = '↩';
                const paras = footnote.children;
                const lastPara = paras[paras.length - 1];
                lastPara.appendChild(backlink);
            }
        });</script><script type=module>/*! instant.page v5.2.0 - (C) 2019-2023 Alexandre Dieulot - https://instant.page/license */
        let t, e, n, o, i, a = null, s = 65, c = new Set; const r = 1111; function d(t) { o = performance.now(); const e = t.target.closest("a"); m(e) && p(e.href, "high") } function u(t) { if (performance.now() - o < r) return; if (!("closest" in t.target)) return; const e = t.target.closest("a"); m(e) && (e.addEventListener("mouseout", f, { passive: !0 }), i = setTimeout(() => { p(e.href, "high"), i = void 0 }, s)) } function l(t) { const e = t.target.closest("a"); m(e) && p(e.href, "high") } function f(t) { t.relatedTarget && t.target.closest("a") == t.relatedTarget.closest("a") || i && (clearTimeout(i), i = void 0) } function h(t) { if (performance.now() - o < r) return; const e = t.target.closest("a"); if (t.which > 1 || t.metaKey || t.ctrlKey) return; if (!e) return; e.addEventListener("click", function (t) { 1337 != t.detail && t.preventDefault() }, { capture: !0, passive: !1, once: !0 }); const n = new MouseEvent("click", { view: window, bubbles: !0, cancelable: !1, detail: 1337 }); e.dispatchEvent(n) } function m(o) { if (o && o.href && (!n || "instant" in o.dataset)) { if (o.origin != location.origin) { if (!(e || "instant" in o.dataset) || !a) return } if (["http:", "https:"].includes(o.protocol) && ("http:" != o.protocol || "https:" != location.protocol) && (t || !o.search || "instant" in o.dataset) && !(o.hash && o.pathname + o.search == location.pathname + location.search || "noInstant" in o.dataset)) return !0 } } function p(t, e = "auto") { if (c.has(t)) return; const n = document.createElement("link"); n.rel = "prefetch", n.href = t, n.fetchPriority = e, n.as = "document", document.head.appendChild(n), c.add(t) } !function () { if (!document.createElement("link").relList.supports("prefetch")) return; const o = "instantVaryAccept" in document.body.dataset || "Shopify" in window, i = navigator.userAgent.indexOf("Chrome/"); i > -1 && (a = parseInt(navigator.userAgent.substring(i + "Chrome/".length))); if (o && a && a < 110) return; const c = "instantMousedownShortcut" in document.body.dataset; t = "instantAllowQueryString" in document.body.dataset, e = "instantAllowExternalLinks" in document.body.dataset, n = "instantWhitelist" in document.body.dataset; const r = { capture: !0, passive: !0 }; let f = !1, v = !1, g = !1; if ("instantIntensity" in document.body.dataset) { const t = document.body.dataset.instantIntensity; if (t.startsWith("mousedown")) f = !0, "mousedown-only" == t && (v = !0); else if (t.startsWith("viewport")) { const e = navigator.connection && navigator.connection.saveData, n = navigator.connection && navigator.connection.effectiveType && navigator.connection.effectiveType.includes("2g"); e || n || ("viewport" == t ? document.documentElement.clientWidth * document.documentElement.clientHeight < 45e4 && (g = !0) : "viewport-all" == t && (g = !0)) } else { const e = parseInt(t); isNaN(e) || (s = e) } } v || document.addEventListener("touchstart", d, r); f ? c || document.addEventListener("mousedown", l, r) : document.addEventListener("mouseover", u, r); c && document.addEventListener("mousedown", h, r); if (g) { let t = window.requestIdleCallback; t || (t = (t => { t() })), t(function () { const t = new IntersectionObserver(e => { e.forEach(e => { if (e.isIntersecting) { const n = e.target; t.unobserve(n), p(n.href) } }) }); document.querySelectorAll("a").forEach(e => { m(e) && t.observe(e) }) }, { timeout: 1500 }) } }();</script>