<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title> Permutation Polynomials </title><link href=https://connorskees.github.io/fonts.css rel=stylesheet><link href=https://connorskees.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://connorskees.github.io/theme/light.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@500&display=swap" rel=stylesheet><link href=https://connorskees.github.io/override.css rel=stylesheet><link href=https://connorskees.github.io/main.css media=screen rel=stylesheet><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script onload="renderMathInElement(document.body, { delimiters: [
                {left: '$$', right: '$$', display: false},
            ] });" crossorigin=anonymous defer integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js></script><body><script src="https://www.googletagmanager.com/gtag/js?id=G-R0T6WNHCFH" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-R0T6WNHCFH');</script><div class=content><header><div class=main><a href=https://connorskees.github.io></a><div class=socials><a class=social href=https://github.com/connorskees/> <object alt=github data=/social_icons/github.svg height=24 type=image/svg+xml width=24></object> </a></div></div><nav><a style="margin-left: 0.7em" href=/>Home</a></nav></header><main><article><div class=title><div class=page-header>Permutation Polynomials</div><div class=meta>Posted on <time>2023-09-19</time></div></div><section class=body><p>A permutation polynomial is any polynomial which acts as a permutation of a given set of numbers. In other terms, the polynomial defines a bijection from x to f(x), or a 1:1 mapping of unique inputs to unique outputs and also that each x value in the input domain appears in the output range.<p>Generally these polynomials operate on a finite range of numbers, most of them having their input modulo some n.<p>The simplest such polynomial is $$f(x) = x$$, because every unique input is mapped to a unique output -- for example, 1 goes to 1, 2 goes to 2, 3 goes to 3, and so on. A slightly more complex example is $$f(x) = 3x$$ for the integers mod 4. In this case, we have the property that:<p>$$ f(0) = 0 $$ <br> $$ f(1) = 3 $$ <br> $$ f(2) = 2 $$ <br> $$ f(3) = 1 $$<p>This gives us [0, 1, 2, 3] => [0, 3, 2, 1] or a permutation of the set of integers mod 4.<p>The rest of this post will be about binary permutation polynomials, or those that are evaluated modulo a power of two. These polynomials have certain properties that make them easier to work with, and are what one would most commonly find in the wild, as the bit-widths of integers in most programming languages are powers of two.<h3 id=testing>Testing</h3><p>Determining whether an arbitrary polynomial is a permutation polynomial has not been shown to be possible using an algorithm that executes in polynomial time. This can make it computationally expensive to determine whether arbitrary polynomials of high degree are permutation polynomials.<p>Polynomials that are modulo a power of two, however, are much easier to reason about and determining whether a given binary polynomial is a permutation polynomial is possible in linear time. A polynomial modulo a power of two is a permutation polynomial if and only if:<ol><li>the 1-degree monomial (i.e. $$x$$) has an odd coefficient<li>the sum of the coefficients of all even degree monomials <em>excluding 0</em> (e.g. $$x^2$$, $$x^4$$, $$x^6$$, ...) is even<li>the sum of the coefficients of all odd degree monomials <em>excluding 1</em> (e.g. $$x^3$$, $$x^5$$, $$x^7$$, ...) is even</ol><p>Examples of valid permutation polynomials modulo a power of 2:<p>$$ 24x^2 + 13x + 15 $$ <br> $$ 13x^4 + 72x^3 + 9x^2 + 85x + 32 $$ <br> $$ 248x^2 + 97x $$<p>Examples of invalid permutation polynomials modulo a power of 2:<p>$$ 9x^2 + x $$ <br> $$ 10x^4 + 3x^2 $$ <br> $$ 19x^4 + 13x^3 + 13x^2 + 13x $$<p>More reading about this property can be found in <a href=https://www.sciencedirect.com/science/article/pii/S107157970090282X?via%3Dihub>this paper</a>.<h3 id=inversion>Inversion</h3><p>Finding the inverse of a permutation polynomial is useful for some problems. Given a permutation polynomial, $$P$$, and its inverse, $$Q$$, these two polynomials have the property that $$P(Q(x)) = x$$ and $$Q(P(x)) = x$$.<p>The first paper to demonstrate a method for inverting arbitrary binary permutation polynomials, is <a href=https://inria.hal.science/hal-01388108/document>Barthelemy et al.</a> in 2016. In it, they use an iterative Newtonian method to converge on a valid inverse using the formula:<p>$$ g_{i+1} = g_i - g_i' \times (f \circ (g_i - X)) $$<p>Where $$f(x)$$ is the original polynomial, and $$g(x)$$ is its inverse. This formula is to be iteratively applied until the inverse has been found.<p>In 2018 Barthelemy released <a href=https://hal.science/hal-01981320/document>a second paper</a> describing two additional algorithms for finding the inverse of a permutation polynomial, this time using Lagrange interpolation. I am less familiar with these algorithms, and as far as I am aware, they are not strictly better than the above Newtonian approach.<p>As the first paper describes, inversion has useful properties in the field of obfuscation where a <a href="https://openaccess.uoc.edu/bitstream/10609/146182/8/arnaugamezFMDP0622report.pdf#page=14">formula such as $$P(E + Q(K))$$ is used to obfuscate constants</a>, where $$K$$ is a constant, $$P$$ is a permutation polynomial, $$Q$$ is its inverse, and $$E$$ is an arbitrarily complex expression that evaluates to 0.</section></article></main></div><script>window.addEventListener('load', function () {
            for (const ref of document.getElementsByClassName('footnote-reference')) {
                const hash = ref.children[0].hash.substring(1);
                const refhash = 'ref:' + hash;
                ref.id = refhash;
            }

            for (const footnote of document.getElementsByClassName('footnote-definition')) {
                const hash = footnote.id;
                const refhash = 'ref:' + hash;
                const backlink = document.createElement('a');
                backlink.href = '#' + refhash;
                backlink.className = 'footnote-backlink';
                backlink.innerText = 'â†©';
                const paras = footnote.children;
                const lastPara = paras[paras.length - 1];
                lastPara.appendChild(backlink);
            }
        });</script><script type=module>/*! instant.page v5.2.0 - (C) 2019-2023 Alexandre Dieulot - https://instant.page/license */
        let t, e, n, o, i, a = null, s = 65, c = new Set; const r = 1111; function d(t) { o = performance.now(); const e = t.target.closest("a"); m(e) && p(e.href, "high") } function u(t) { if (performance.now() - o < r) return; if (!("closest" in t.target)) return; const e = t.target.closest("a"); m(e) && (e.addEventListener("mouseout", f, { passive: !0 }), i = setTimeout(() => { p(e.href, "high"), i = void 0 }, s)) } function l(t) { const e = t.target.closest("a"); m(e) && p(e.href, "high") } function f(t) { t.relatedTarget && t.target.closest("a") == t.relatedTarget.closest("a") || i && (clearTimeout(i), i = void 0) } function h(t) { if (performance.now() - o < r) return; const e = t.target.closest("a"); if (t.which > 1 || t.metaKey || t.ctrlKey) return; if (!e) return; e.addEventListener("click", function (t) { 1337 != t.detail && t.preventDefault() }, { capture: !0, passive: !1, once: !0 }); const n = new MouseEvent("click", { view: window, bubbles: !0, cancelable: !1, detail: 1337 }); e.dispatchEvent(n) } function m(o) { if (o && o.href && (!n || "instant" in o.dataset)) { if (o.origin != location.origin) { if (!(e || "instant" in o.dataset) || !a) return } if (["http:", "https:"].includes(o.protocol) && ("http:" != o.protocol || "https:" != location.protocol) && (t || !o.search || "instant" in o.dataset) && !(o.hash && o.pathname + o.search == location.pathname + location.search || "noInstant" in o.dataset)) return !0 } } function p(t, e = "auto") { if (c.has(t)) return; const n = document.createElement("link"); n.rel = "prefetch", n.href = t, n.fetchPriority = e, n.as = "document", document.head.appendChild(n), c.add(t) } !function () { if (!document.createElement("link").relList.supports("prefetch")) return; const o = "instantVaryAccept" in document.body.dataset || "Shopify" in window, i = navigator.userAgent.indexOf("Chrome/"); i > -1 && (a = parseInt(navigator.userAgent.substring(i + "Chrome/".length))); if (o && a && a < 110) return; const c = "instantMousedownShortcut" in document.body.dataset; t = "instantAllowQueryString" in document.body.dataset, e = "instantAllowExternalLinks" in document.body.dataset, n = "instantWhitelist" in document.body.dataset; const r = { capture: !0, passive: !0 }; let f = !1, v = !1, g = !1; if ("instantIntensity" in document.body.dataset) { const t = document.body.dataset.instantIntensity; if (t.startsWith("mousedown")) f = !0, "mousedown-only" == t && (v = !0); else if (t.startsWith("viewport")) { const e = navigator.connection && navigator.connection.saveData, n = navigator.connection && navigator.connection.effectiveType && navigator.connection.effectiveType.includes("2g"); e || n || ("viewport" == t ? document.documentElement.clientWidth * document.documentElement.clientHeight < 45e4 && (g = !0) : "viewport-all" == t && (g = !0)) } else { const e = parseInt(t); isNaN(e) || (s = e) } } v || document.addEventListener("touchstart", d, r); f ? c || document.addEventListener("mousedown", l, r) : document.addEventListener("mouseover", u, r); c && document.addEventListener("mousedown", h, r); if (g) { let t = window.requestIdleCallback; t || (t = (t => { t() })), t(function () { const t = new IntersectionObserver(e => { e.forEach(e => { if (e.isIntersecting) { const n = e.target; t.unobserve(n), p(n.href) } }) }); document.querySelectorAll("a").forEach(e => { m(e) && t.observe(e) }) }, { timeout: 1500 }) } }();</script>