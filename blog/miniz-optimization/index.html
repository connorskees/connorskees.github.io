<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title> Optimizing Low Hanging Fruit in `miniz_oxide` </title><link href=https://connorskees.github.io/fonts.css rel=stylesheet><link href=https://connorskees.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://connorskees.github.io/theme/light.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@500&display=swap" rel=stylesheet><link href=https://connorskees.github.io/override.css rel=stylesheet><link href=https://connorskees.github.io/main.css media=screen rel=stylesheet><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script onload="renderMathInElement(document.body, { delimiters: [
                {left: '$$', right: '$$', display: false},
            ] });" crossorigin=anonymous defer integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js></script><body><script src="https://www.googletagmanager.com/gtag/js?id=G-R0T6WNHCFH" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-R0T6WNHCFH');</script><div class=content><header><div class=main><a href=https://connorskees.github.io></a><div class=socials><a class=social href=https://github.com/connorskees/> <object alt=github data=/social_icons/github.svg height=24 type=image/svg+xml width=24></object> </a></div></div><nav><a style="margin-left: 0.7em" href=/>Home</a></nav></header><main><article><div class=title><div class=page-header>Optimizing Low Hanging Fruit in `miniz_oxide`</div><div class=meta>Posted on <time>2023-01-12</time></div></div><section class=body><p>I'm working on a large blog post investigating the performance characteristics of various PNG decoders across several programming languages. A large part of this work is profiling and benchmarking them.<p>The first decoder I've been looking at as part of this work is <a href=https://crates.io/crates/png><code>image-rs/png</code></a>, which is the most downloaded PNG decoder in the rust ecosystem.<p>To start this kind of work, I like getting some cursory profiles and benchmarks just to see what the libraries are doing. The image I like to start with is this <a href=https://commons.wikimedia.org/wiki/File:Periodic_table_large.png>PNG of the periodic table of elements</a> from Wikimedia Commons. This file is in the public domain, so we can do whatever we want with it and it's a pretty good size at ~2.2mb.<p>To benchmark <code>image-rs/png</code>, I have to create a binary that uses it, since by itself it's just a library. I've created a simple rust program that looks like this:<pre class=language-rs data-lang=rs style=background-color:#0f1419;color:#bfbab0;><code class=language-rs data-lang=rs><span style=color:#ff7733;>fn </span><span style=color:#ffb454;>main</span><span>() {
</span><span>    </span><span style=color:#ff7733;>const </span><span style=color:#f29718;>BYTES</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span>[</span><span style=color:#ff7733;>u8</span><span>] </span><span style=color:#f29668;>= </span><span style=color:#f07178;>include_bytes!</span><span>(</span><span style=color:#c2d94c;>"Periodic_table_large.png"</span><span>)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    </span><span style=color:#ff7733;>let</span><span> decoder </span><span style=color:#f29668;>= </span><span>png</span><span style=color:#f29668;>::</span><span>Decoder</span><span style=color:#f29668;>::</span><span>new(</span><span style=color:#f29718;>BYTES</span><span>)</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> reader </span><span style=color:#f29668;>=</span><span> decoder</span><span style=color:#f29668;>.</span><span style=color:#f07178;>read_info</span><span>()</span><span style=color:#f29668;>.</span><span style=color:#f07178;>unwrap</span><span>()</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    </span><span style=color:#ff7733;>let</span><span> bpp </span><span style=color:#f29668;>=</span><span> reader</span><span style=color:#f29668;>.</span><span style=color:#f07178;>info</span><span>()</span><span style=color:#f29668;>.</span><span style=color:#f07178;>bytes_per_pixel</span><span>()</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>let</span><span> width </span><span style=color:#f29668;>=</span><span> reader</span><span style=color:#f29668;>.</span><span style=color:#f07178;>info</span><span>()</span><span style=color:#f29668;>.</span><span>width</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>let</span><span> length </span><span style=color:#f29668;>=</span><span> reader</span><span style=color:#f29668;>.</span><span style=color:#f07178;>info</span><span>()</span><span style=color:#f29668;>.</span><span style=color:#f07178;>raw_row_length</span><span>()</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> buffer </span><span style=color:#f29668;>= </span><span style=color:#f07178;>vec!</span><span>[</span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>;</span><span> bpp </span><span style=color:#f29668;>*</span><span> width </span><span style=color:#f29668;>as </span><span style=color:#ff7733;>usize </span><span style=color:#f29668;>*</span><span> length </span><span style=color:#f29668;>as </span><span style=color:#ff7733;>usize</span><span>]</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    </span><span style=color:#ff7733;>while let </span><span style=font-style:italic;color:#39bae6;>Some</span><span>(row) </span><span style=color:#f29668;>=</span><span> reader</span><span style=color:#f29668;>.</span><span style=color:#f07178;>next_row</span><span>()</span><span style=color:#f29668;>.</span><span style=color:#f07178;>unwrap</span><span>() {
</span><span>        buffer</span><span style=color:#f29668;>.</span><span style=color:#f07178;>extend_from_slice</span><span>(row</span><span style=color:#f29668;>.</span><span style=color:#f07178;>data</span><span>())</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>
</span><span>    std</span><span style=color:#f29668;>::</span><span>hint</span><span style=color:#f29668;>::</span><span>black_box(buffer)</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>This isn't perfect, but it works for my purposes right now. A more robust solution would elide the command line altogether and only benchmark the PNG operations themselves, but at the start I just want a rough idea of how the library performs.<p>I've made a few optimizations to improve the benchmark. Namely, I avoid file IO by using rust's <code>include_bytes!</code> macro, which will load the entire contents of a file into the binary at compile time instead of at runtime, and I pre-allocate the entire output buffer in order to avoid having to resize it during the benchmark.<p>I'm using <a href=https://doc.rust-lang.org/stable/std/hint/fn.black_box.html><code>std::hint::black_box</code></a> to make sure the compiler doesn't optimize anything differently just because we aren't actually using the result of the decoding.<p>To run this benchmark I'm going to use <a href=https://github.com/sharkdp/hyperfine><code>hyperfine</code></a>, which is a great tool for ad hoc benchmarking of command line utilities.<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>cargo</span><span> b</span><span style=color:#f29718;> --release
</span><span style=color:#ffb454;>hyperfine</span><span> ./target/release/test-png
</span></code></pre><p>gives us<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>Benchmark</span><span> 1: ./target/release/test-image-png
</span><span>  </span><span style=color:#ffb454;>Time</span><span> (mean ± σ)</span><span style=color:#f07178;>:</span><span>     253.5 ms ±   3.3 ms    </span><span style=color:#ff7733;>[</span><span>User: 211.7 ms, System: 39.9 ms</span><span style=color:#ff7733;>]
</span><span>  </span><span style=color:#ffb454;>Range</span><span> (min … max)</span><span style=color:#f07178;>:</span><span>   250.6 ms … 262.4 ms    11 runs
</span></code></pre><p>So about 250ms to decode a 2mb image. Is that reasonable? We don't really know -- this is the first decoder we're looking at. Intuitively it feels a bit slow. This is executing on a dedicated Linux server that's not running any other programs.<p>Out of curiosity, let's profile the binary using <code>perf</code> to see where it's spending its time.<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>perf</span><span> record</span><span style=color:#f29718;> -e</span><span> cpu-clock ./target/release/test-png
</span></code></pre><p>prints<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#f07178;>[</span><span> perf record: Woken up 1 times to write data </span><span style=color:#f07178;>]
</span><span style=color:#f07178;>[</span><span> perf record: Captured and wrote 0.047 MB perf.data (1017 samples) </span><span style=color:#ffb454;>]
</span></code></pre><p>and creates a <code>perf.data</code> file. We can read this file using <a href=https://man7.org/linux/man-pages/man1/perf-report.1.html><code>perf report</code></a>.<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>perf</span><span> report
</span></code></pre><p>This opens an interactive viewer in our terminal that looks something like this:<p><img alt="perf report output" src=https://connorskees.github.io/blog/miniz-optimization/../perf-report-1.png><p>Reading this output isn't too complex. The first column displays a percentage of execution spent in the function. The last column shows the symbol name, which is either the actual name of a function or a memory address.<p>Does this profile make sense?<p>The second line looks like it belongs. We'd expect decoding the next interlaced row to be the bulk of the time in a benchmark where we loop over the rows of a PNG file. <a href=https://github.com/image-rs/image-png/pull/336><code>image-rs/png</code> uses <code>#![forbid(unsafe)]</code></a>, which means that unless they're using an external crate, they likely don't use handwritten SIMD intrinsics to decode <a href=https://www.w3.org/TR/PNG-Filters.html>PNG filters</a>. LLVM <em>can</em> do ok autovectorizing sometimes, but in general one would expect the equivalent higher level code to not be as fast. It makes sense that this might be a bit slow.<p>So we expect that most of the time would be spent in <code>png::decoder::Reader&LTR>::next_raw_interlaced_row</code>, but what about <code>miniz_oxide::inflate::core::transfer</code>?<p>From the name it's clear that this is coming from the DEFLATE library that <code>image-rs/png</code> relies on. It sounds like all it's doing is transferring data from one buffer to another. If we look at the implementation in <code>miniz_oxide</code>, we can see that's exactly what it's doing:<pre class=language-rs data-lang=rs style=background-color:#0f1419;color:#bfbab0;><code class=language-rs data-lang=rs><span style=color:#bfbab0cc;>#</span><span>[</span><span style=color:#ffb454;>inline</span><span>]
</span><span style=color:#ff7733;>fn </span><span style=color:#ffb454;>transfer</span><span>(
</span><span>    </span><span style=color:#f29718;>out_slice</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>],
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>source_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>out_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>match_len</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>out_buf_size_mask</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>) {
</span><span>    </span><span style=color:#ff7733;>for </span><span style=color:#f29668;>_ in </span><span style=color:#f29718;>0</span><span style=color:#f29668;>..</span><span>match_len </span><span style=color:#f29668;>>> </span><span style=color:#f29718;>2 </span><span>{
</span><span>        out_slice[out_pos] </span><span style=color:#f29668;>=</span><span> out_slice[source_pos </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        source_pos </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>        out_pos </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#ff7733;>match</span><span> match_len </span><span style=color:#f29668;>& </span><span style=color:#f29718;>3 </span><span>{
</span><span>        </span><span style=color:#f29718;>0 </span><span style=color:#f29668;>=> </span><span>()</span><span style=color:#bfbab0cc;>,
</span><span>        </span><span style=color:#f29718;>1 </span><span style=color:#f29668;>=></span><span> out_slice[out_pos] </span><span style=color:#f29668;>=</span><span> out_slice[source_pos </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>,
</span><span>        </span><span style=color:#f29718;>2 </span><span style=color:#f29668;>=> </span><span>{
</span><span>            out_slice[out_pos] </span><span style=color:#f29668;>=</span><span> out_slice[source_pos </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>            out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        }
</span><span>        </span><span style=color:#f29718;>3 </span><span style=color:#f29668;>=> </span><span>{
</span><span>            out_slice[out_pos] </span><span style=color:#f29668;>=</span><span> out_slice[source_pos </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>            out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>            out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        }
</span><span>        </span><span style=color:#f29668;>_ => </span><span style=color:#f07178;>unreachable!</span><span>()</span><span style=color:#bfbab0cc;>,
</span><span>    }
</span><span>}
</span></code></pre><p>Given a buffer, <code>out_slice</code>, this function will read bytes from within <code>out_slice</code> starting at <code>source_pos</code> and copying them to <code>out_slice</code> starting at <code>out_pos</code>. The specific way it does the copying is a bit more complex, but that's the gist of it.<p>Our PNG decoder spends 1/3rd of its time copying bytes. That raises a few red flags. Modern <code>memcpy</code> is pretty fast and shouldn't be a bottleneck for our decoder. This function probably isn't being optimized to a straight <code>memcpy</code>, but that's the upper bound we should be targeting, and I think we should be able to get pretty close. Let's look at the disassembly to see what's going wrong. When we look at the disassembly, let's ignore the bottom <code>match</code> statement. That's only executed once per function call and should have a much smaller impact on perf compared to the loop<sup class=footnote-reference><a href=#1>1</a></sup>.<pre class=language-asm data-lang=asm style=background-color:#0f1419;color:#bfbab0;><code class=language-asm data-lang=asm><span style=color:#ffb454;>miniz_oxide::core::inflate::transfer:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>push    </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>r8</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jb      </span><span style=color:#ffb454;>.LBB0_11
</span><span style=font-style:italic;color:#5c6773;>        ; match_len >> 2
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>shr     </span><span style=color:#f29718;>r8</span><span>, </span><span style=color:#f29718;>2
</span><span style=color:#ffb454;>.LBB0_2:
</span><span style=font-style:italic;color:#5c6773;>        ; out_slice[out_pos] = out_slice[source_pos & out_buf_size_mask];
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rdx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>r9
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_12
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_14
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rax</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rcx</span><span>], </span><span style=color:#f29718;>al
</span><span>
</span><span style=font-style:italic;color:#5c6773;>        ; out_slice[out_pos + 1] = out_slice[(source_pos + 1) & out_buf_size_mask];
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>inc     </span><span style=color:#f29718;>rdx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rdx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>r9
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_15
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>r10</span><span>, [</span><span style=color:#f29718;>rcx </span><span>+ </span><span style=color:#f29718;>1</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>r10</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_16
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rax</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rcx </span><span>+ </span><span style=color:#f29718;>1</span><span>], </span><span style=color:#f29718;>al
</span><span>
</span><span style=font-style:italic;color:#5c6773;>        ; out_slice[out_pos + 2] = out_slice[(source_pos + 2) & out_buf_size_mask];
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>inc     </span><span style=color:#f29718;>rdx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rdx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>r9
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_18
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>r10</span><span>, [</span><span style=color:#f29718;>rcx </span><span>+ </span><span style=color:#f29718;>2</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>r10</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_19
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rax</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rcx </span><span>+ </span><span style=color:#f29718;>2</span><span>], </span><span style=color:#f29718;>al
</span><span>
</span><span style=font-style:italic;color:#5c6773;>        ; out_slice[out_pos + 3] = out_slice[(source_pos + 3) & out_buf_size_mask];
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>inc     </span><span style=color:#f29718;>rdx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rdx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>r9
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_20
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>r10</span><span>, [</span><span style=color:#f29718;>rcx </span><span>+ </span><span style=color:#f29718;>3</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>r10</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_21
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rax</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rcx </span><span>+ </span><span style=color:#f29718;>3</span><span>], </span><span style=color:#f29718;>al
</span><span>
</span><span style=font-style:italic;color:#5c6773;>        ; source_pos += 4;
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>inc     </span><span style=color:#f29718;>rdx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>dec     </span><span style=color:#f29718;>r8
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jne     </span><span style=color:#ffb454;>.LBB0_2
</span><span style=color:#ffb454;>.LBB0_11:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>pop     </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>ret
</span><span>
</span><span style=font-style:italic;color:#5c6773;>; ... several lines of panic handling code are omitted
</span></code></pre><p>Let's break the disassembly down in chunks.<p>We see a block like this repeated 4 times.<pre class=language-asm data-lang=asm style=background-color:#0f1419;color:#bfbab0;><code class=language-asm data-lang=asm><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rdx
</span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>r9
</span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_12
</span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_14
</span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rax</span><span>]
</span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rcx</span><span>], </span><span style=color:#f29718;>al
</span></code></pre><p>Each instance corresponds to the line <code>out_slice[out_pos] = out_slice[(source_pos + X) & out_buf_size_mask];</code> in the original source. Since we compiled this on Linux, we're using the <a href=https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI>System V ABI</a>'s calling conventions. We pass in <code>out_slice</code> as the first argument. In rust, slices are represented by a pointer and a length. These values get passed to our function in <code>rdi</code> and <code>rsi</code> respectively. The next parameter, in this case <code>source_pos</code>, is passed to the function in <code>rdx</code>. So we move the value of <code>source_pos</code> from the register <code>rdx</code> to the register <code>rax</code>. Then we bitmask it with <code>r9</code>, which contains the value of <code>out_buf_size_mask</code>.<p>Then we compare that bitmasked value to the length of <code>out_slice</code> stored in the register <code>rsi</code>. The <code>jae</code> instruction, jump if above or equal, does exactly what it sounds like. If <code>rax</code> is greater than or equal to the length, then we jump to <code>.LBB0_12</code>, which sets us up to panic. This is an array bounds check. We have a similar check in the two instructions below, where we check that <code>out_pos</code> is also in the bounds of the slice.<p>Following that, we move the value at <code>out_slice[source_pos]</code> into the register <code>eax</code>. Then we move the lower 8 bits of that register to <code>out_slice[out_pos]</code>.<p>We repeat this 4 times until we get to the end of the loop.<pre class=language-asm data-lang=asm style=background-color:#0f1419;color:#bfbab0;><code class=language-asm data-lang=asm><span style=color:#ff7733;>add     </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ff7733;>inc     </span><span style=color:#f29718;>rdx
</span><span style=color:#ff7733;>dec     </span><span style=color:#f29718;>r8
</span><span style=color:#ff7733;>jne     </span><span style=color:#ffb454;>.LBB0_2
</span></code></pre><p>Then we add 4 to <code>out_pos</code>. During iteration we've already been adding to <code>source_pos</code>, so here we just have to increment its value by 1. Then we subtract 1 from our loop counter and jump to the start of the loop if it isn't zero.<p>You might already be able to see a bit of inefficiency, even if you aren't that familiar with assembly. On every iteration we perform 2 bounds checks per line, for a total of 8 bounds checks per iteration. Bounds checks do add overhead, but much like integer overflow checks, they aren't by themselves <a href=https://danluu.com/integer-overflow/><em>that</em> slow</a>. In our case, going out of bounds is exceptional and should never happen during the course of regular execution, which means the branch predictor should do a really good job here.<p>Typically the problem with integer overflow checks and bounds checks is that they prevent other optimizations, like autovectorization. Perhaps that's what's happening here -- we're doing a lot of bounds checks inside a tight loop and so LLVM can't optimize it that well. Let's see what removing the bounds checks does to the codegen.<p>Let's start by trying to remove them in safe rust. We can try <a href=https://gist.github.com/kvark/f067ba974446f7c5ce5bd544fe370186#assert-conditions-beforehand>asserting one large length condition</a> at the start of the function, and hope that LLVM is able to elide the later checks.<p>The new code looks something like this:<pre class=language-rs data-lang=rs style=background-color:#0f1419;color:#bfbab0;><code class=language-rs data-lang=rs><span style=color:#ff7733;>fn </span><span style=color:#ffb454;>transfer</span><span>(
</span><span>    </span><span style=color:#f29718;>out_slice</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>],
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>source_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>out_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>match_len</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>out_buf_size_mask</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>) {
</span><span>    </span><span style=color:#f07178;>assert!</span><span>(out_slice</span><span style=color:#f29668;>.</span><span style=color:#f07178;>len</span><span>() </span><span style=color:#f29668;>> </span><span>(match_len </span><span style=color:#f29668;>>> </span><span style=color:#f29718;>2</span><span>) </span><span style=color:#f29668;>* </span><span style=color:#f29718;>4 </span><span style=color:#f29668;>+</span><span> out_pos </span><span style=color:#f29668;>- </span><span style=color:#f29718;>1</span><span>)</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#f07178;>assert!</span><span>(out_slice</span><span style=color:#f29668;>.</span><span style=color:#f07178;>len</span><span>() </span><span style=color:#f29668;>> </span><span>(match_len </span><span style=color:#f29668;>>> </span><span style=color:#f29718;>2</span><span>) </span><span style=color:#f29668;>* </span><span style=color:#f29718;>4 </span><span style=color:#f29668;>+</span><span> source_pos </span><span style=color:#f29668;>- </span><span style=color:#f29718;>1</span><span>)</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>for </span><span style=color:#f29668;>_ in </span><span style=color:#f29718;>0</span><span style=color:#f29668;>..</span><span>match_len </span><span style=color:#f29668;>>> </span><span style=color:#f29718;>2 </span><span>{
</span><span>        out_slice[out_pos] </span><span style=color:#f29668;>=</span><span> out_slice[source_pos </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        source_pos </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>        out_pos </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>}
</span></code></pre><p>Remember we're omitting the final match statement for simplicity. Let's look at the disassembly for the first line in our loop body now.<pre class=language-asm data-lang=asm style=background-color:#0f1419;color:#bfbab0;><code class=language-asm data-lang=asm><span style=font-style:italic;color:#5c6773;>; out_slice[out_pos] = out_slice[source_pos & out_buf_size_mask];
</span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rdx
</span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>r9
</span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_16
</span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_18
</span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rax</span><span>]
</span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rcx</span><span>], </span><span style=color:#f29718;>al
</span></code></pre><p>The bounds checks are still there :/<p>LLVM wasn't smart enough to elide them based on our assert at the start of the function. Admittedly the check was a bit complex. What if we try asserting at the start of the loop body? That should be a lot simpler for the compiler to reason about.<p>Our new code looks like this<pre class=language-rs data-lang=rs style=background-color:#0f1419;color:#bfbab0;><code class=language-rs data-lang=rs><span style=color:#ff7733;>fn </span><span style=color:#ffb454;>transfer</span><span>(
</span><span>    </span><span style=color:#f29718;>out_slice</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>],
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>source_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>out_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>match_len</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>out_buf_size_mask</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>) {
</span><span>    </span><span style=color:#ff7733;>for </span><span style=color:#f29668;>_ in </span><span style=color:#f29718;>0</span><span style=color:#f29668;>..</span><span>match_len </span><span style=color:#f29668;>>> </span><span style=color:#f29718;>2 </span><span>{
</span><span>        </span><span style=color:#f07178;>assert!</span><span>(out_slice</span><span style=color:#f29668;>.</span><span style=color:#f07178;>len</span><span>() </span><span style=color:#f29668;>></span><span> out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>)</span><span style=color:#bfbab0cc;>;
</span><span>        </span><span style=color:#f07178;>assert!</span><span>(out_slice</span><span style=color:#f29668;>.</span><span style=color:#f07178;>len</span><span>() </span><span style=color:#f29668;>></span><span> source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>)</span><span style=color:#bfbab0cc;>;
</span><span>        out_slice[out_pos] </span><span style=color:#f29668;>=</span><span> out_slice[source_pos </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        source_pos </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>        out_pos </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>}
</span></code></pre><p>Looking at the assembly,<pre class=language-asm data-lang=asm style=background-color:#0f1419;color:#bfbab0;><code class=language-asm data-lang=asm><span style=font-style:italic;color:#5c6773;>; out_slice[out_pos] = out_slice[source_pos & out_buf_size_mask];
</span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>rax</span><span>, [</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>rbx</span><span>]
</span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>r9
</span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_12
</span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>r11</span><span>, [</span><span style=color:#f29718;>rcx </span><span>+ </span><span style=color:#f29718;>rbx</span><span>]
</span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>r11</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_14
</span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rax</span><span>]
</span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>r14 </span><span>+ </span><span style=color:#f29718;>rbx </span><span>- </span><span style=color:#f29718;>3</span><span>], </span><span style=color:#f29718;>al
</span></code></pre><p>The <code>cmp</code> and <code>jae</code> are still there twice for every line in the loop. At this point let's just give up and use unsafe to see if what we're trying to do will actually have a meaningful impact on the codegen. We can use <a href=https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked><code>slice::get_unchecked</code></a> and <a href=https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked_mut><code>slice::get_unchecked_mut</code></a> to elide bounds checks that we know are safe.<pre class=language-rs data-lang=rs style=background-color:#0f1419;color:#bfbab0;><code class=language-rs data-lang=rs><span style=color:#ff7733;>fn </span><span style=color:#ffb454;>transfer</span><span>(
</span><span>    </span><span style=color:#f29718;>out_slice</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>],
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>source_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>out_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>match_len</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>out_buf_size_mask</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>) {
</span><span>    </span><span style=color:#f07178;>assert!</span><span>(out_slice</span><span style=color:#f29668;>.</span><span style=color:#f07178;>len</span><span>() </span><span style=color:#f29668;>> </span><span>(match_len </span><span style=color:#f29668;>>> </span><span style=color:#f29718;>2</span><span>) </span><span style=color:#f29668;>* </span><span style=color:#f29718;>4 </span><span style=color:#f29668;>+</span><span> out_pos </span><span style=color:#f29668;>- </span><span style=color:#f29718;>1</span><span>)</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#f07178;>assert!</span><span>(out_slice</span><span style=color:#f29668;>.</span><span style=color:#f07178;>len</span><span>() </span><span style=color:#f29668;>> </span><span>(match_len </span><span style=color:#f29668;>>> </span><span style=color:#f29718;>2</span><span>) </span><span style=color:#f29668;>* </span><span style=color:#f29718;>4 </span><span style=color:#f29668;>+</span><span> source_pos </span><span style=color:#f29668;>- </span><span style=color:#f29718;>1</span><span>)</span><span style=color:#bfbab0cc;>;
</span><span>
</span><span>    </span><span style=color:#ff7733;>for </span><span style=color:#f29668;>_ in </span><span style=color:#f29718;>0</span><span style=color:#f29668;>..</span><span>match_len </span><span style=color:#f29668;>>> </span><span style=color:#f29718;>2 </span><span>{
</span><span>        </span><span style=color:#ff7733;>unsafe </span><span>{
</span><span>            </span><span style=color:#f29668;>*</span><span>out_slice</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked_mut</span><span>(out_pos) </span><span style=color:#f29668;>=
</span><span>                </span><span style=color:#f29668;>*</span><span>out_slice</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>(source_pos </span><span style=color:#f29668;>&</span><span> out_buf_size_mask)</span><span style=color:#bfbab0cc;>;
</span><span>            </span><span style=color:#f29668;>*</span><span>out_slice</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked_mut</span><span>(out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>) </span><span style=color:#f29668;>=
</span><span>                </span><span style=color:#f29668;>*</span><span>out_slice</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>((source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask)</span><span style=color:#bfbab0cc;>;
</span><span>            </span><span style=color:#f29668;>*</span><span>out_slice</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked_mut</span><span>(out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>) </span><span style=color:#f29668;>=
</span><span>                </span><span style=color:#f29668;>*</span><span>out_slice</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>((source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask)</span><span style=color:#bfbab0cc;>;
</span><span>            </span><span style=color:#f29668;>*</span><span>out_slice</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked_mut</span><span>(out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>) </span><span style=color:#f29668;>=
</span><span>                </span><span style=color:#f29668;>*</span><span>out_slice</span><span style=color:#f29668;>.</span><span style=color:#f07178;>get_unchecked</span><span>((source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask)</span><span style=color:#bfbab0cc;>;
</span><span>        }
</span><span>        source_pos </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>        out_pos </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>}
</span></code></pre><p>We'll add back our original asserts to make sure we don't accidentally do any out-of-bounds reads. What does the codegen for this look like?<pre class=language-asm data-lang=asm style=background-color:#0f1419;color:#bfbab0;><code class=language-asm data-lang=asm><span style=color:#ffb454;>example::transfer:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>push    </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>r10</span><span>, </span><span style=color:#f29718;>r8
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>r10</span><span>, -</span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>rax</span><span>, [</span><span style=color:#f29718;>r10 </span><span>+ </span><span style=color:#f29718;>rcx</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_6
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>r10</span><span>, </span><span style=color:#f29718;>rdx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>r10</span><span>, </span><span style=color:#f29718;>rsi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jae     </span><span style=color:#ffb454;>.LBB0_7
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>r8</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jb      </span><span style=color:#ffb454;>.LBB0_5
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>shr     </span><span style=color:#f29718;>r8</span><span>, </span><span style=color:#f29718;>2
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>r8</span><span>, </span><span style=color:#f29718;>2
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>r10d</span><span>, </span><span style=color:#f29718;>1
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmovae  </span><span style=color:#f29718;>r10</span><span>, </span><span style=color:#f29718;>r8
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>rdi
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>rcx</span><span>, </span><span style=color:#f29718;>3
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>xor     </span><span style=color:#f29718;>esi</span><span>, </span><span style=color:#f29718;>esi
</span><span style=color:#ffb454;>.LBB0_4:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>rdx
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>r9
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rax</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rcx </span><span>+ </span><span style=color:#f29718;>4</span><span>*</span><span style=color:#f29718;>rsi </span><span>- </span><span style=color:#f29718;>3</span><span>], </span><span style=color:#f29718;>al
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>rax</span><span>, [</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>1</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>r9
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rax</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rcx </span><span>+ </span><span style=color:#f29718;>4</span><span>*</span><span style=color:#f29718;>rsi </span><span>- </span><span style=color:#f29718;>2</span><span>], </span><span style=color:#f29718;>al
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>rax</span><span>, [</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>2</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>r9
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rax</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rcx </span><span>+ </span><span style=color:#f29718;>4</span><span>*</span><span style=color:#f29718;>rsi </span><span>- </span><span style=color:#f29718;>1</span><span>], </span><span style=color:#f29718;>al
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>rax</span><span>, [</span><span style=color:#f29718;>rdx </span><span>+ </span><span style=color:#f29718;>3</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>and     </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>r9
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>movzx   </span><span style=color:#f29718;>eax</span><span>, </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rdi </span><span>+ </span><span style=color:#f29718;>rax</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f07178;>byte ptr </span><span>[</span><span style=color:#f29718;>rcx </span><span>+ </span><span style=color:#f29718;>4</span><span>*</span><span style=color:#f29718;>rsi</span><span>], </span><span style=color:#f29718;>al
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>rax</span><span>, [</span><span style=color:#f29718;>rsi </span><span>+ </span><span style=color:#f29718;>1</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>add     </span><span style=color:#f29718;>rdx</span><span>, </span><span style=color:#f29718;>4
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>rsi</span><span>, </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>cmp     </span><span style=color:#f29718;>r10</span><span>, </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>jne     </span><span style=color:#ffb454;>.LBB0_4
</span><span style=color:#ffb454;>.LBB0_5:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>pop     </span><span style=color:#f29718;>rax
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>ret
</span><span style=color:#ffb454;>.LBB0_6:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>rdi</span><span>, [</span><span style=color:#f29718;>rip </span><span>+ </span><span style=color:#ffb454;>.L__unnamed_1</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>rdx</span><span>, [</span><span style=color:#f29718;>rip </span><span>+ </span><span style=color:#ffb454;>.L__unnamed_2</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>esi</span><span>, </span><span style=color:#f29718;>66
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>call    </span><span style=color:#f07178;>qword ptr </span><span>[</span><span style=color:#f29718;>rip </span><span>+ </span><span style=color:#ffb454;>core::panicking::panic@GOTPCREL</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>ud2
</span><span style=color:#ffb454;>.LBB0_7:
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>rdi</span><span>, [</span><span style=color:#f29718;>rip </span><span>+ </span><span style=color:#ffb454;>.L__unnamed_3</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>lea     </span><span style=color:#f29718;>rdx</span><span>, [</span><span style=color:#f29718;>rip </span><span>+ </span><span style=color:#ffb454;>.L__unnamed_4</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>mov     </span><span style=color:#f29718;>esi</span><span>, </span><span style=color:#f29718;>69
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>call    </span><span style=color:#f07178;>qword ptr </span><span>[</span><span style=color:#f29718;>rip </span><span>+ </span><span style=color:#ffb454;>core::panicking::panic@GOTPCREL</span><span>]
</span><span style=color:#ffb454;>        </span><span style=color:#ff7733;>ud2
</span></code></pre><p>No bounds checks! And a lot fewer instructions than what we started with (55 lines vs 82 originally). So how much faster is the code without bounds checks?<p>Let's start by cloning the <code>miniz_oxide</code> repo and <a href=https://doc.rust-lang.org/cargo/reference/overriding-dependencies.html>vendoring our dependencies so we can modify them locally</a>.<p>If our original <code>Cargo.toml</code> looked like this,<pre class=language-toml data-lang=toml style=background-color:#0f1419;color:#bfbab0;><code class=language-toml data-lang=toml><span>[</span><span style=color:#59c2ff;>dependencies</span><span>]
</span><span style=color:#59c2ff;>png </span><span>= </span><span style=color:#c2d94c;>"0.17.7"
</span></code></pre><p>we just have to add this section<pre class=language-toml data-lang=toml style=background-color:#0f1419;color:#bfbab0;><code class=language-toml data-lang=toml><span>[</span><span style=color:#59c2ff;>patch</span><span style=color:#bfbab0cc;>.</span><span style=color:#59c2ff;>crates-io</span><span>]
</span><span style=color:#59c2ff;>miniz_oxide </span><span>= { </span><span style=color:#59c2ff;>path </span><span>= </span><span style=color:#c2d94c;>"../miniz_oxide/miniz_oxide" </span><span>}
</span></code></pre><p>Before we start making changes, lets make a copy of the original binary we used to benchmark so we can use it as a point of comparison for our changes.<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>cp</span><span> ./target/release/test-png ./original
</span></code></pre><p>Next let's replace the old implementation of <code>transfer</code> with our new one. Then we can build and compare the two implementations.<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>cargo</span><span> b</span><span style=color:#f29718;> --release
</span><span style=color:#ffb454;>hyperfine</span><span> ./original ./target/release/test-png</span><span style=color:#f29718;> --warmup</span><span> 5
</span></code></pre><p>which prints<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>Benchmark</span><span> 1: ./original
</span><span>  </span><span style=color:#ffb454;>Time</span><span> (mean ± σ)</span><span style=color:#f07178;>:</span><span>     255.9 ms ±   4.5 ms    </span><span style=color:#ff7733;>[</span><span>User: 216.9 ms, System: 35.5 ms</span><span style=color:#ff7733;>]
</span><span>  </span><span style=color:#ffb454;>Range</span><span> (min … max)</span><span style=color:#f07178;>:</span><span>   251.7 ms … 265.2 ms    11 runs
</span><span> 
</span><span style=color:#ffb454;>Benchmark</span><span> 2: ./target/release/test-image-png
</span><span>  </span><span style=color:#ffb454;>Time</span><span> (mean ± σ)</span><span style=color:#f07178;>:</span><span>     254.5 ms ±   5.0 ms    </span><span style=color:#ff7733;>[</span><span>User: 214.7 ms, System: 38.4 ms</span><span style=color:#ff7733;>]
</span><span>  </span><span style=color:#ffb454;>Range</span><span> (min … max)</span><span style=color:#f07178;>:</span><span>   250.2 ms … 267.3 ms    11 runs
</span><span> 
</span><span style=color:#ffb454;>Summary
</span><span>  </span><span style=color:#c2d94c;>'./target/release/test-image-png'</span><span> ran
</span><span>    </span><span style=color:#ffb454;>1.01</span><span> ± 0.03 times faster than </span><span style=color:#c2d94c;>'./original'
</span></code></pre><p>A 1% improvement. These results are barely above random noise, even though we removed bounds checks. We're doing a bit of new work now for the 2 assertions at the start of the function, but that wouldn't be the cause for such a small speed-up. Fundamentally the performance benefits from removing bounds checks aren't helping us here and the optimizer isn't able to do much better even with them gone. If we want to speed up this function, we have to start thinking about the algorithm.<p>Looking at the assembly, right now our implementation is entirely scalar. We load one array element at a time, mask it, and then copy it to the out position. It should be trivial for the compiler to vectorize this, so what's preventing it?<p>There's two problems here. First, we mask the array indices with <code>out_buf_size_mask</code>, which means its possible for us to be forced to copy non-consecutive elements from the array. Non-consecutive reads may prevent us from using SIMD here at all.<p>The other issue is that our data is highly dependent on previous calculations. This is especially apparent when <code>source_pos</code> and <code>out_pos</code> differ by less than 4. We can see this if we think through an example where our array is <code>[1, 2, 3, 4, 5, 6, 7, 8]</code>, <code>source_pos</code> is 0, and <code>out_pos</code> is 2. We can pretend we don't do any masking for now. Here's what the code looks like if we substitute concrete values for <code>source_pos</code> and <code>out_pos</code>:<pre class=language-python data-lang=python style=background-color:#0f1419;color:#bfbab0;><code class=language-python data-lang=python><span>out_slice </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>3</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>5</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>6</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>7</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>8</span><span>]
</span><span>
</span><span>out_slice[</span><span style=color:#f29718;>2</span><span>] </span><span style=color:#f29668;>= </span><span>out_slice[</span><span style=color:#f29718;>0</span><span>]
</span><span>out_slice[</span><span style=color:#f29718;>3</span><span>] </span><span style=color:#f29668;>= </span><span>out_slice[</span><span style=color:#f29718;>1</span><span>]
</span><span>
</span><span style=font-style:italic;color:#5c6773;># !!!
</span><span>out_slice[</span><span style=color:#f29718;>4</span><span>] </span><span style=color:#f29668;>= </span><span>out_slice[</span><span style=color:#f29718;>2</span><span>]
</span><span>out_slice[</span><span style=color:#f29718;>5</span><span>] </span><span style=color:#f29668;>= </span><span>out_slice[</span><span style=color:#f29718;>3</span><span>]
</span></code></pre><p>After the first iteration, the array is now <code>[1, 2, 1, 2, 1, 2, 7, 8]</code>.<p>On the third line of our loop, we depend on the results of the first line of our loop. if we tried to load all the values for this iteration at once, we wouldn't get the correct result. We'll have to be really creative if we end up having to work around this dependency in the general case<sup class=footnote-reference><a href=#2>2</a></sup>.<p>Let's look at the first problem -- masking can cause non-consecutive reads. Is there any way around this? One thing we could look at is the value we're masking by. If it's always the same value, we might be able to make some interesting optimizations. To inspect its value, we can use an ad hoc profiling tool called <a href=https://blog.mozilla.org/nnethercote/2018/07/24/ad-hoc-profiling/><code>counts</code></a> that I really love. To use it, we just need to insert some prints into the code and then pipe the results to <code>counts</code>.<p>Our new code looks like this:<pre class=language-rs data-lang=rs style=background-color:#0f1419;color:#bfbab0;><code class=language-rs data-lang=rs><span style=color:#ff7733;>fn </span><span style=color:#ffb454;>transfer</span><span>(
</span><span>    </span><span style=color:#f29718;>out_slice</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>],
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>source_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>out_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>match_len</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>out_buf_size_mask</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>) {
</span><span>    </span><span style=color:#f07178;>println!</span><span>(</span><span style=color:#c2d94c;>"</span><span style=color:#f29718;>{}</span><span style=color:#c2d94c;>"</span><span style=color:#bfbab0cc;>,</span><span> out_buf_size_mask)</span><span style=color:#bfbab0cc;>;
</span><span>    </span><span style=color:#ff7733;>for </span><span style=color:#f29668;>_ in </span><span style=color:#f29718;>0</span><span style=color:#f29668;>..</span><span>match_len </span><span style=color:#f29668;>>> </span><span style=color:#f29718;>2 </span><span>{
</span><span>        out_slice[out_pos] </span><span style=color:#f29668;>=</span><span> out_slice[source_pos </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>        source_pos </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>        out_pos </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>}
</span></code></pre><p>Pretty simple. Then to use it:<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>cargo</span><span> r</span><span style=color:#f29718;> --release </span><span style=color:#f29668;>| </span><span style=color:#ffb454;>counts
</span></code></pre><p>We run in release mode just because it's prohibitively slow to execute in debug mode. After running this, we get our results:<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>255047</span><span> counts
</span><span>(  </span><span style=color:#ffb454;>1</span><span>)   255047 (100.0%,100.0%)</span><span style=color:#f07178;>:</span><span> 18446744073709551615
</span></code></pre><p>Looking at the output, the first number in parentheses is just the line number of the output. The second number is the count for the given value. The last number in the output is the value that we printed.<p>Based on this, we can see that the mask value is always the same. It looks like some large 64 bit integer. I don't have special 64 bit integers memorized, so lets open up a python repl to see what it looks like in binary.<pre class=language-python data-lang=python style=background-color:#0f1419;color:#bfbab0;><code class=language-python data-lang=python><span style=color:#f29668;>>>> </span><span style=color:#f07178;>bin</span><span>(</span><span style=color:#f29718;>18446744073709551615</span><span>)
</span><span style=color:#c2d94c;>'0b1111111111111111111111111111111111111111111111111111111111111111'
</span></code></pre><p>The number is all ones. Let's check how long it is. The number we're hoping for is 64:<pre class=language-python data-lang=python style=background-color:#0f1419;color:#bfbab0;><code class=language-python data-lang=python><span style=color:#f29668;>>>> </span><span style=color:#f07178;>len</span><span>(</span><span style=font-style:italic;color:#39bae6;>_</span><span>) </span><span style=color:#f29668;>- </span><span style=color:#f29718;>2
</span><span style=color:#f29718;>64
</span></code></pre><p>Ok, so in every case that we call this function for this input, we don't actually do any masking. That's our first problem solved. We can just special case our code when <code>out_buf_size_mask === usize::MAX</code>.<p>Our next issue is the data dependency when the difference between <code>out_pos</code> and <code>source_pos</code> is small enough that they overlap. Let's see how often this comes up in practice. We can use <code>counts</code> here again to help us:<pre class=language-rs data-lang=rs style=background-color:#0f1419;color:#bfbab0;><code class=language-rs data-lang=rs><span style=color:#ff7733;>fn </span><span style=color:#ffb454;>transfer</span><span>(
</span><span>    </span><span style=color:#f29718;>out_slice</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>],
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>source_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>out_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>match_len</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>out_buf_size_mask</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>) {
</span><span>    </span><span style=color:#f07178;>println!</span><span>(</span><span style=color:#c2d94c;>"</span><span style=color:#f29718;>{}</span><span style=color:#c2d94c;>"</span><span style=color:#bfbab0cc;>,</span><span> source_pos</span><span style=color:#f29668;>.</span><span style=color:#f07178;>abs_diff</span><span>(out_pos))</span><span style=color:#bfbab0cc;>;
</span><span>    
</span><span>    </span><span style=font-style:italic;color:#5c6773;>// ...
</span><span>}
</span></code></pre><pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>cargo</span><span> r</span><span style=color:#f29718;> --release </span><span style=color:#f29668;>| </span><span style=color:#ffb454;>counts
</span></code></pre><p>gives us<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>255047</span><span> counts
</span><span>(  </span><span style=color:#ffb454;>1</span><span>)   253652 (99.5%, 99.5%)</span><span style=color:#f07178;>:</span><span> 1
</span><span>(  </span><span style=color:#ffb454;>2</span><span>)      516 ( 0.2%, 99.7%)</span><span style=color:#f07178;>:</span><span> 4
</span><span>(  </span><span style=color:#ffb454;>3</span><span>)      150 ( 0.1%, 99.7%)</span><span style=color:#f07178;>:</span><span> 1200
</span><span>(  </span><span style=color:#ffb454;>4</span><span>)       46 ( 0.0%, 99.7%)</span><span style=color:#f07178;>:</span><span> 24001
</span><span>(  </span><span style=color:#ffb454;>5</span><span>)       24 ( 0.0%, 99.7%)</span><span style=color:#f07178;>:</span><span> 2400
</span><span>(  </span><span style=color:#ffb454;>6</span><span>)       16 ( 0.0%, 99.7%)</span><span style=color:#f07178;>:</span><span> 8
</span><span>(  </span><span style=color:#ffb454;>7</span><span>)       12 ( 0.0%, 99.8%)</span><span style=color:#f07178;>:</span><span> 281
</span><span>(  </span><span style=color:#ffb454;>8</span><span>)       12 ( 0.0%, 99.8%)</span><span style=color:#f07178;>:</span><span> 285
</span><span>(  </span><span style=color:#ffb454;>9</span><span>)       11 ( 0.0%, 99.8%)</span><span style=color:#f07178;>:</span><span> 120
</span><span>( </span><span style=color:#ffb454;>10</span><span>)       10 ( 0.0%, 99.8%)</span><span style=color:#f07178;>:</span><span> 265
</span><span>( </span><span style=color:#ffb454;>11</span><span>)       10 ( 0.0%, 99.8%)</span><span style=color:#f07178;>:</span><span> 3600
</span><span>( </span><span style=color:#ffb454;>12</span><span>)       10 ( 0.0%, 99.8%)</span><span style=color:#f07178;>:</span><span> 4800
</span><span>( </span><span style=color:#ffb454;>13</span><span>)        8 ( 0.0%, 99.8%)</span><span style=color:#f07178;>:</span><span> 273
</span><span>( </span><span style=color:#ffb454;>14</span><span>)        8 ( 0.0%, 99.8%)</span><span style=color:#f07178;>:</span><span> 277
</span><span>( </span><span style=color:#ffb454;>15</span><span>)        8 ( 0.0%, 99.8%)</span><span style=color:#f07178;>:</span><span> 305
</span><span style=color:#ffb454;>...</span><span> 215 more results omitted
</span></code></pre><p>Quite a bit of variance. But if we look at the percentages, 99.5% of cases have a difference of 1. The rest of the cases all have pretty low counts relative to the total. So now we know which case we want to investigate.<p>Right now we're checking the absolute difference, so we're not actually checking whether <code>out_pos</code> is greater than or less than <code>source_pos</code>. This can affect the changes that we're making, so let's see which one is more common.<pre class=language-rs data-lang=rs style=background-color:#0f1419;color:#bfbab0;><code class=language-rs data-lang=rs><span style=color:#ff7733;>fn </span><span style=color:#ffb454;>transfer</span><span>(
</span><span>    </span><span style=color:#f29718;>out_slice</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>],
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>source_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>out_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>match_len</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>out_buf_size_mask</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>) {
</span><span>    </span><span style=color:#f07178;>println!</span><span>(</span><span style=color:#c2d94c;>"</span><span style=color:#f29718;>{:?}</span><span style=color:#c2d94c;>"</span><span style=color:#bfbab0cc;>,</span><span> source_pos</span><span style=color:#f29668;>.</span><span style=color:#f07178;>cmp</span><span>(</span><span style=color:#f29668;>&</span><span>out_pos))</span><span style=color:#bfbab0cc;>;
</span><span>    
</span><span>    </span><span style=font-style:italic;color:#5c6773;>// ...
</span><span>}
</span></code></pre><pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>cargo</span><span> r</span><span style=color:#f29718;> --release </span><span style=color:#f29668;>| </span><span style=color:#ffb454;>counts
</span></code></pre><pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>255047</span><span> counts
</span><span>(  </span><span style=color:#ffb454;>1</span><span>)   255047 (100.0%,100.0%)</span><span style=color:#f07178;>:</span><span> Less
</span></code></pre><p><code>source_pos</code> is always less than <code>out_pos</code>. That means we can just ignore all other cases. That's pretty helpful for our optimization work. Now we can start trying to come up with a fast path:<pre class=language-rs data-lang=rs style=background-color:#0f1419;color:#bfbab0;><code class=language-rs data-lang=rs><span style=color:#ff7733;>fn </span><span style=color:#ffb454;>transfer</span><span>(
</span><span>    </span><span style=color:#f29718;>out_slice</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>],
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>source_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>out_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>match_len</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>out_buf_size_mask</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>) {
</span><span>    </span><span style=color:#ff7733;>if</span><span> out_buf_size_mask </span><span style=color:#f29668;>== </span><span style=color:#ff7733;>usize</span><span style=color:#f29668;>::</span><span style=color:#f29718;>MAX </span><span style=color:#f29668;>&&</span><span> source_pos</span><span style=color:#f29668;>.</span><span style=color:#f07178;>abs_diff</span><span>(out_pos) </span><span style=color:#f29668;>== </span><span style=color:#f29718;>1 </span><span>{
</span><span>        </span><span style=font-style:italic;color:#5c6773;>// our super-fast specialized code goes here
</span><span>    } </span><span style=color:#ff7733;>else </span><span>{
</span><span>        </span><span style=color:#ff7733;>for </span><span style=color:#f29668;>_ in </span><span style=color:#f29718;>0</span><span style=color:#f29668;>..</span><span>match_len </span><span style=color:#f29668;>>> </span><span style=color:#f29718;>2 </span><span>{
</span><span>            out_slice[out_pos] </span><span style=color:#f29668;>=</span><span> out_slice[source_pos </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>            out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>            out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>            out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>            source_pos </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>            out_pos </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>Let's revisit our example from before. If we start with an array of <code>[1, 2, 3, 4, 5, 6, 7, 8]</code>, let's say <code>source_pos</code> is 0, and <code>out_pos</code> is 1 this time. We don't have to worry about masking because we know the number we're masking by is <code>usize::MAX</code>. Let's think through what the array looks like after 1 iteration.<pre class=language-python data-lang=python style=background-color:#0f1419;color:#bfbab0;><code class=language-python data-lang=python><span>out_slice </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>3</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>5</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>6</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>7</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>8</span><span>]
</span><span>
</span><span style=font-style:italic;color:#5c6773;># [1, 2, 3, 4, 5, 6, 7, 8]
</span><span>out_slice[</span><span style=color:#f29718;>1</span><span>] </span><span style=color:#f29668;>= </span><span>out_slice[</span><span style=color:#f29718;>0</span><span>]
</span><span style=font-style:italic;color:#5c6773;># [1, 1, 3, 4, 5, 6, 7, 8]
</span><span>out_slice[</span><span style=color:#f29718;>2</span><span>] </span><span style=color:#f29668;>= </span><span>out_slice[</span><span style=color:#f29718;>1</span><span>]
</span><span style=font-style:italic;color:#5c6773;># [1, 1, 1, 4, 5, 6, 7, 8]
</span><span>out_slice[</span><span style=color:#f29718;>2</span><span>] </span><span style=color:#f29668;>= </span><span>out_slice[</span><span style=color:#f29718;>2</span><span>]
</span><span style=font-style:italic;color:#5c6773;># [1, 1, 1, 1, 5, 6, 7, 8]
</span><span>out_slice[</span><span style=color:#f29718;>4</span><span>] </span><span style=color:#f29668;>= </span><span>out_slice[</span><span style=color:#f29718;>3</span><span>]
</span></code></pre><p>There's a pretty clear -- and exciting -- pattern here. The range is just converted to be the same value. So if we calculate the end position, we can pretty succinctly do <code>memset(&out_slice[out_pos], out_slice[source_pos], end - out_pos)</code>. In rust we can get this codegen pretty easily with <code>out_slice[out_pos..end].fill(out_slice[source_pos])</code>. To calculate the <code>end</code>, we can reuse some of our assertion code from before.<p>Our new code is<pre class=language-rs data-lang=rs style=background-color:#0f1419;color:#bfbab0;><code class=language-rs data-lang=rs><span style=color:#ff7733;>fn </span><span style=color:#ffb454;>transfer</span><span>(
</span><span>    </span><span style=color:#f29718;>out_slice</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29668;>&</span><span style=color:#ff7733;>mut</span><span> [</span><span style=color:#ff7733;>u8</span><span>],
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>source_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#ff7733;>mut </span><span style=color:#f29718;>out_pos</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>match_len</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>    </span><span style=color:#f29718;>out_buf_size_mask</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>usize</span><span>,
</span><span>) {
</span><span>    </span><span style=color:#ff7733;>if</span><span> out_buf_size_mask </span><span style=color:#f29668;>== </span><span style=color:#ff7733;>usize</span><span style=color:#f29668;>::</span><span style=color:#f29718;>MAX </span><span style=color:#f29668;>&&</span><span> source_pos</span><span style=color:#f29668;>.</span><span style=color:#f07178;>abs_diff</span><span>(out_pos) </span><span style=color:#f29668;>== </span><span style=color:#f29718;>1 </span><span>{
</span><span>        </span><span style=color:#ff7733;>let</span><span> fill_byte </span><span style=color:#f29668;>=</span><span> out_slice[source_pos]</span><span style=color:#bfbab0cc;>;
</span><span>        </span><span style=color:#ff7733;>let</span><span> end </span><span style=color:#f29668;>= </span><span>(match_len </span><span style=color:#f29668;>>> </span><span style=color:#f29718;>2</span><span>) </span><span style=color:#f29668;>* </span><span style=color:#f29718;>4 </span><span style=color:#f29668;>+</span><span> out_pos</span><span style=color:#bfbab0cc;>;
</span><span>        out_slice[out_pos</span><span style=color:#f29668;>..</span><span>end]</span><span style=color:#f29668;>.</span><span style=color:#f07178;>fill</span><span>(fill_byte)</span><span style=color:#bfbab0cc;>;
</span><span>        source_pos </span><span style=color:#f29668;>=</span><span> end </span><span style=color:#f29668;>- </span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>;
</span><span>        out_pos </span><span style=color:#f29668;>=</span><span> end</span><span style=color:#bfbab0cc;>;
</span><span>    } </span><span style=color:#ff7733;>else </span><span>{
</span><span>        </span><span style=color:#ff7733;>for </span><span style=color:#f29668;>_ in </span><span style=color:#f29718;>0</span><span style=color:#f29668;>..</span><span>match_len </span><span style=color:#f29668;>>> </span><span style=color:#f29718;>2 </span><span>{
</span><span>            out_slice[out_pos] </span><span style=color:#f29668;>=</span><span> out_slice[source_pos </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>            out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>            out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>2</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>            out_slice[out_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>] </span><span style=color:#f29668;>=</span><span> out_slice[(source_pos </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>3</span><span>) </span><span style=color:#f29668;>&</span><span> out_buf_size_mask]</span><span style=color:#bfbab0cc;>;
</span><span>            source_pos </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>            out_pos </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>We can't compute the <code>fill_byte</code> as an argument to <code>.fill(..)</code> because of rust's borrow checker, so we have to bring out as a separate variable. We have to update the <code>source_pos</code> and <code>out_pos</code> in our fast path because the later match statement depends on their values.<p>Now let's compile this and compare it to our original binary.<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>cargo</span><span> b</span><span style=color:#f29718;> --release
</span><span style=color:#ffb454;>hyperfine</span><span> ./original ./target/release/test-png</span><span style=color:#f29718;> --warmup</span><span> 5
</span></code></pre><pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>Benchmark</span><span> 1: ./original
</span><span>  </span><span style=color:#ffb454;>Time</span><span> (mean ± σ)</span><span style=color:#f07178;>:</span><span>     253.1 ms ±   3.1 ms    </span><span style=color:#ff7733;>[</span><span>User: 207.9 ms, System: 43.4 ms</span><span style=color:#ff7733;>]
</span><span>  </span><span style=color:#ffb454;>Range</span><span> (min … max)</span><span style=color:#f07178;>:</span><span>   250.5 ms … 260.7 ms    11 runs
</span><span> 
</span><span style=color:#ffb454;>Benchmark</span><span> 2: ./target/release/test-image-png
</span><span>  </span><span style=color:#ffb454;>Time</span><span> (mean ± σ)</span><span style=color:#f07178;>:</span><span>     164.8 ms ±   1.3 ms    </span><span style=color:#ff7733;>[</span><span>User: 129.9 ms, System: 34.0 ms</span><span style=color:#ff7733;>]
</span><span>  </span><span style=color:#ffb454;>Range</span><span> (min … max)</span><span style=color:#f07178;>:</span><span>   163.7 ms … 168.1 ms    17 runs
</span><span> 
</span><span style=color:#ffb454;>Summary
</span><span>  </span><span style=color:#c2d94c;>'./target/release/test-image-png'</span><span> ran
</span><span>    </span><span style=color:#ffb454;>1.54</span><span> ± 0.02 times faster than </span><span style=color:#c2d94c;>'./original'
</span></code></pre><p><em>A 50% improvement</em>. This benchmark is testing how long it takes to decode <em>an entire PNG</em>, so this would be a pretty meaningful optimization. Let's double check this is real and that we didn't break anything by running <code>miniz_oxide</code>'s test suite.<pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#f07178;>cd</span><span> ../miniz_oxide
</span><span style=color:#ffb454;>cargo</span><span> t</span><span style=color:#f29718;> --all
</span></code></pre><pre class=language-sh data-lang=sh style=background-color:#0f1419;color:#bfbab0;><code class=language-sh data-lang=sh><span style=color:#ffb454;>test</span><span> result: ok. 22 passed</span><span style=color:#f29668;>; </span><span style=color:#ffb454;>0</span><span> failed</span><span style=color:#f29668;>; </span><span style=color:#ffb454;>0</span><span> ignored</span><span style=color:#f29668;>; </span><span style=color:#ffb454;>0</span><span> measured</span><span style=color:#f29668;>; </span><span style=color:#ffb454;>0</span><span> filtered out</span><span style=color:#f29668;>; </span><span style=color:#ffb454;>finished</span><span> in 0.01s
</span><span>
</span><span style=font-style:italic;color:#5c6773;># ... full test results omitted
</span></code></pre><p>All of the tests pass; this is likely a sound optimization. At this point we should be comfortable making a PR with our changes.<p>This patch was submitted as <a href=https://github.com/Frommi/miniz_oxide/pull/131>#131</a> to the <code>miniz_oxide</code> repo. It contains a bit more than described here. <code>miniz_oxide</code> has its own benchmark suite, and after looking at it we can make a few small changes to improve performance there as well.<p>The results of our optimization are pretty striking: for some inputs we see a more than 2x improvement. <code>miniz_oxide</code> is ported from a C library that has roughly the same performance characteristics. What this means is, after our changes, <code>miniz_oxide</code> is now also more than 2x faster than the original C implementation for these inputs.<p>The relevant benchmarks are:<pre class=language-rs data-lang=rs style=background-color:#0f1419;color:#bfbab0;><code class=language-rs data-lang=rs><span style=font-style:italic;color:#5c6773;>// before
</span><span>test oxide</span><span style=color:#f29668;>::</span><span>decompress_compressed_lvl_1 </span><span style=color:#f29668;>...</span><span> bench</span><span style=color:#bfbab0cc;>:      </span><span style=color:#f29718;>89</span><span style=color:#bfbab0cc;>,</span><span style=color:#f29718;>253</span><span> ns</span><span style=color:#f29668;>/</span><span>iter (</span><span style=color:#f29668;>+/- </span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>,</span><span style=color:#f29718;>412</span><span>)
</span><span>test oxide</span><span style=color:#f29668;>::</span><span>decompress_compressed_lvl_6 </span><span style=color:#f29668;>...</span><span> bench</span><span style=color:#bfbab0cc;>:     </span><span style=color:#f29718;>176</span><span style=color:#bfbab0cc;>,</span><span style=color:#f29718;>299</span><span> ns</span><span style=color:#f29668;>/</span><span>iter (</span><span style=color:#f29668;>+/- </span><span style=color:#f29718;>6</span><span style=color:#bfbab0cc;>,</span><span style=color:#f29718;>266</span><span>)
</span><span>test oxide</span><span style=color:#f29668;>::</span><span>decompress_compressed_lvl_9 </span><span style=color:#f29668;>...</span><span> bench</span><span style=color:#bfbab0cc;>:     </span><span style=color:#f29718;>175</span><span style=color:#bfbab0cc;>,</span><span style=color:#f29718;>840</span><span> ns</span><span style=color:#f29668;>/</span><span>iter (</span><span style=color:#f29668;>+/- </span><span style=color:#f29718;>3</span><span style=color:#bfbab0cc;>,</span><span style=color:#f29718;>131</span><span>)
</span></code></pre><pre class=language-rs data-lang=rs style=background-color:#0f1419;color:#bfbab0;><code class=language-rs data-lang=rs><span style=font-style:italic;color:#5c6773;>// after
</span><span>test oxide</span><span style=color:#f29668;>::</span><span>decompress_compressed_lvl_1 </span><span style=color:#f29668;>...</span><span> bench</span><span style=color:#bfbab0cc;>:      </span><span style=color:#f29718;>83</span><span style=color:#bfbab0cc;>,</span><span style=color:#f29718;>992</span><span> ns</span><span style=color:#f29668;>/</span><span>iter (</span><span style=color:#f29668;>+/- </span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>,</span><span style=color:#f29718;>347</span><span>)
</span><span>test oxide</span><span style=color:#f29668;>::</span><span>decompress_compressed_lvl_6 </span><span style=color:#f29668;>...</span><span> bench</span><span style=color:#bfbab0cc;>:      </span><span style=color:#f29718;>76</span><span style=color:#bfbab0cc;>,</span><span style=color:#f29718;>640</span><span> ns</span><span style=color:#f29668;>/</span><span>iter (</span><span style=color:#f29668;>+/- </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>,</span><span style=color:#f29718;>288</span><span>)
</span><span>test oxide</span><span style=color:#f29668;>::</span><span>decompress_compressed_lvl_9 </span><span style=color:#f29668;>...</span><span> bench</span><span style=color:#bfbab0cc;>:      </span><span style=color:#f29718;>76</span><span style=color:#bfbab0cc;>,</span><span style=color:#f29718;>791</span><span> ns</span><span style=color:#f29668;>/</span><span>iter (</span><span style=color:#f29668;>+/- </span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>,</span><span style=color:#f29718;>978</span><span>)
</span></code></pre><div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>In practice this was verified by looking at the annotated disassembly in <code>perf report</code></div><div class=footnote-definition id=2><sup class=footnote-definition-label>2</sup><p>An implementation of this problem in the general case can be found <a href=https://gist.github.com/connorskees/955439d1ad62a4dcbe4f594a293c6187>here</a>, though it ends up not being much faster</div></section></article></main></div><script>window.addEventListener('load', function () {
            for (const ref of document.getElementsByClassName('footnote-reference')) {
                const hash = ref.children[0].hash.substring(1);
                const refhash = 'ref:' + hash;
                ref.id = refhash;
            }

            for (const footnote of document.getElementsByClassName('footnote-definition')) {
                const hash = footnote.id;
                const refhash = 'ref:' + hash;
                const backlink = document.createElement('a');
                backlink.href = '#' + refhash;
                backlink.className = 'footnote-backlink';
                backlink.innerText = '↩';
                const paras = footnote.children;
                const lastPara = paras[paras.length - 1];
                lastPara.appendChild(backlink);
            }
        });</script><script type=module>/*! instant.page v5.2.0 - (C) 2019-2023 Alexandre Dieulot - https://instant.page/license */
        let t, e, n, o, i, a = null, s = 65, c = new Set; const r = 1111; function d(t) { o = performance.now(); const e = t.target.closest("a"); m(e) && p(e.href, "high") } function u(t) { if (performance.now() - o < r) return; if (!("closest" in t.target)) return; const e = t.target.closest("a"); m(e) && (e.addEventListener("mouseout", f, { passive: !0 }), i = setTimeout(() => { p(e.href, "high"), i = void 0 }, s)) } function l(t) { const e = t.target.closest("a"); m(e) && p(e.href, "high") } function f(t) { t.relatedTarget && t.target.closest("a") == t.relatedTarget.closest("a") || i && (clearTimeout(i), i = void 0) } function h(t) { if (performance.now() - o < r) return; const e = t.target.closest("a"); if (t.which > 1 || t.metaKey || t.ctrlKey) return; if (!e) return; e.addEventListener("click", function (t) { 1337 != t.detail && t.preventDefault() }, { capture: !0, passive: !1, once: !0 }); const n = new MouseEvent("click", { view: window, bubbles: !0, cancelable: !1, detail: 1337 }); e.dispatchEvent(n) } function m(o) { if (o && o.href && (!n || "instant" in o.dataset)) { if (o.origin != location.origin) { if (!(e || "instant" in o.dataset) || !a) return } if (["http:", "https:"].includes(o.protocol) && ("http:" != o.protocol || "https:" != location.protocol) && (t || !o.search || "instant" in o.dataset) && !(o.hash && o.pathname + o.search == location.pathname + location.search || "noInstant" in o.dataset)) return !0 } } function p(t, e = "auto") { if (c.has(t)) return; const n = document.createElement("link"); n.rel = "prefetch", n.href = t, n.fetchPriority = e, n.as = "document", document.head.appendChild(n), c.add(t) } !function () { if (!document.createElement("link").relList.supports("prefetch")) return; const o = "instantVaryAccept" in document.body.dataset || "Shopify" in window, i = navigator.userAgent.indexOf("Chrome/"); i > -1 && (a = parseInt(navigator.userAgent.substring(i + "Chrome/".length))); if (o && a && a < 110) return; const c = "instantMousedownShortcut" in document.body.dataset; t = "instantAllowQueryString" in document.body.dataset, e = "instantAllowExternalLinks" in document.body.dataset, n = "instantWhitelist" in document.body.dataset; const r = { capture: !0, passive: !0 }; let f = !1, v = !1, g = !1; if ("instantIntensity" in document.body.dataset) { const t = document.body.dataset.instantIntensity; if (t.startsWith("mousedown")) f = !0, "mousedown-only" == t && (v = !0); else if (t.startsWith("viewport")) { const e = navigator.connection && navigator.connection.saveData, n = navigator.connection && navigator.connection.effectiveType && navigator.connection.effectiveType.includes("2g"); e || n || ("viewport" == t ? document.documentElement.clientWidth * document.documentElement.clientHeight < 45e4 && (g = !0) : "viewport-all" == t && (g = !0)) } else { const e = parseInt(t); isNaN(e) || (s = e) } } v || document.addEventListener("touchstart", d, r); f ? c || document.addEventListener("mousedown", l, r) : document.addEventListener("mouseover", u, r); c && document.addEventListener("mousedown", h, r); if (g) { let t = window.requestIdleCallback; t || (t = (t => { t() })), t(function () { const t = new IntersectionObserver(e => { e.forEach(e => { if (e.isIntersecting) { const n = e.target; t.unobserve(n), p(n.href) } }) }); document.querySelectorAll("a").forEach(e => { m(e) && t.observe(e) }) }, { timeout: 1500 }) } }();</script>