<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title> Merge-Tree — A Data Structure for Real-Time Collaborative Text Editing </title><link href=https://connorskees.github.io/fonts.css rel=stylesheet><link href=https://connorskees.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://connorskees.github.io/theme/light.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@500&display=swap" rel=stylesheet><link href=https://connorskees.github.io/override.css rel=stylesheet><link href=https://connorskees.github.io/main.css media=screen rel=stylesheet><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script onload="renderMathInElement(document.body, { delimiters: [
                {left: '$$', right: '$$', display: false},
            ] });" crossorigin=anonymous defer integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js></script><body><script src="https://www.googletagmanager.com/gtag/js?id=G-R0T6WNHCFH" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-R0T6WNHCFH');</script><div class=content><header><div class=main><a href=https://connorskees.github.io></a><div class=socials><a class=social href=https://github.com/connorskees/> <object alt=github data=/social_icons/github.svg height=24 type=image/svg+xml width=24></object> </a></div></div><nav><a style="margin-left: 0.7em" href=/>Home</a></nav></header><main><article><div class=title><div class=page-header>Merge-Tree — A Data Structure for Real-Time Collaborative Text Editing</div><div class=meta>Posted on <time>2024-02-29</time></div></div><section class=body><p>Merge-tree is a distributed, low-latency B+ tree used to implement real-time collaborative editing of sequences, strings, and matrices.<p>This is an entry-level explanation of the core architecture and algorithms backing the merge-tree data structure and is the sort of explanation I would have wanted in my first 3 months of working on it. The goal of this document is that someone with no context on collaborative editing can be able to reason about the code at a high level.<p>This document only describes the core merge-tree algorithms and does not touch on the ancillary algorithms that are necessary for the merge-tree to function, but which do not live inside the merge-tree itself. This includes problems like persistence, real-time communication, algorithms built on top of merge-tree such as those specific to strings or matrices, and some server-side functionality that will be discussed later.<p>Although in theory a merge-tree need not operate on text, I find it easiest to reason about the core algorithms in the context of text editing, and so much of the higher-level explanation will center around that.<h2 id=overview>Overview</h2><p>At its simplest, a merge-tree defines the following operations:<ol><li><code>insert(index: number, text: string)</code><li><code>removeRange(start: number, end: number)</code><li><code>annotateRange(start: number, end: number, properties: object)</code></ol><p>You can insert text, remove a range of text, or give a key-value property to a range of text.<p>The API of the merge-tree is based around these operations. These can be thought of as JSON payloads containing the above function parameters. For example, <code>{ type: "insert", index: 0, text: "foo" }</code>.<p>In addition to these parameters, each operation ("<strong>op</strong>") has a <strong>sequence number</strong> associated with it, abbreviated "seq". This is a <a href=https://akuli.github.io/math-derivations/eqs-and-funcs/incdec-funcs.html>strictly increasing</a> integer that (simplifying a bit)<sup class=footnote-reference><a href=#1>1</a></sup> is unique to a given operation. The sequence number determines the order in which operations get applied. That is, the operation at seq n <em>must</em> be processed before the op at seq n+1.<p>If you are familiar with <a href=https://gunkies.org/wiki/Sequence_number>sequence numbers in the context of network protocols like TCP</a>, this is very similar.<p>The exact machinery for sequencing ops lives outside of merge-tree and is not necessary for understanding the core algorithms.<p>If we look at a simplified example of an op stream:<pre class=language-json data-lang=json style=background-color:#0f1419;color:#bfbab0;><code class=language-json data-lang=json><span>[
</span><span>    { </span><span style=color:#c2d94c;>"type"</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"insert"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"index"</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"text"</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"hello"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"seq"</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>1 </span><span>}</span><span style=color:#bfbab0cc;>,
</span><span>    { </span><span style=color:#c2d94c;>"type"</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"remove"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"start"</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"end"</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>5</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"seq"</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>2 </span><span>}</span><span style=color:#bfbab0cc;>,
</span><span>    { </span><span style=color:#c2d94c;>"type"</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"insert"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"index"</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"text"</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"i"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"seq"</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>3 </span><span>}</span><span style=color:#bfbab0cc;>,
</span><span>]
</span></code></pre><p>Here, we have a sequence of ops that constructs the following string:<p>seq 1: "hello" (insert string "hello")<br> seq 2: "h" (remove range <code>[1-5)</code>)<br> seq 3: "hi" (insert string "i")<p>This is relatively straightforward behavior to reason about, and should be roughly what you would expect to see from a regular string data structure used for normal text editing.<p>The complexity of merge-tree comes from its support for collaboration. In order to talk about collaboration, we have to add 2 more fields to our ops: <strong>client id</strong> (<code>clientId</code>) and <strong>reference sequence number</strong> (<code>refSeq</code>).<p>The clientId is exactly what it sounds like: a unique identifier for a particular user in a collaboration session. If three people are editing a document in their browser at the same time, each user would be given a unique clientId. In practice these are UUIDs, though merge-tree has some optimizations that convert the UUIDs to small integers by <a href=https://en.wikipedia.org/wiki/String_interning>interning</a> them.<p>The reference sequence number is slightly more complex, and will require a bit more background to fully describe.<p>In general, collaboration looks something like this:<p>One user, or client, will create an op and send it to the server. The server will process the op and assign it a sequence number. For the client that sent the op, the server will acknowledge the op and send that client back a sequence number. For the other clients, it will send them this op with the sequence number attached.<p>All clients then process this op and update their refSeq. The refSeq is the sequence number of the last operation that a particular client processed from the server.<p>When I first started working on merge-tree, I had the misconception that two ops were submitted concurrently if they had the same sequence number, but they are actually concurrent if both ops have a refSeq below the sequence number of the other.<p>Let's take a look at a simple example with two clients:<p>We'll start with the string "abc". We have two clients, "A" and "B". Both clients insert a single character at position 1 at the same time, without knowing about the existence of the other.<p>Here's what our op stream might look like.<pre class=language-ts data-lang=ts style=background-color:#0f1419;color:#bfbab0;><code class=language-ts data-lang=ts><span>[
</span><span>    { seq</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span>refSeq</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>, </span><span>clientId</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"A"</span><span style=color:#bfbab0cc;>, </span><span>type</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"insert"</span><span style=color:#bfbab0cc;>, </span><span>text</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"X"</span><span style=color:#bfbab0cc;>, </span><span>index</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>1 </span><span>}</span><span style=color:#bfbab0cc;>,
</span><span>    { seq</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span>refSeq</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>, </span><span>clientId</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"B"</span><span style=color:#bfbab0cc;>, </span><span>type</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"insert"</span><span style=color:#bfbab0cc;>, </span><span>text</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"Y"</span><span style=color:#bfbab0cc;>, </span><span>index</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>1 </span><span>}</span><span style=color:#bfbab0cc;>,
</span><span>]
</span></code></pre><p>Our string would look like this:<p>start: "abc"<br> seq 1: "aXbc"<br> seq 2: "aYXbc"<p>Note that the refSeq of the two ops is the same. This means that the two operations occurred without either client being aware of the other. The sequence number on client A's op is lower than client B's op. This means that client A's op likely reached the server before client B's, though this does not imply anything about the time that either op occurred. It's also worth mentioning that even if the two ops <em>had</em> reached the server in the exact same nanosecond, they would still have different sequence numbers.<p>Because neither op was aware of the other, we would consider them to be concurrent.<p>The scenario above looks like this in prose:<p>When the server processes the op from client A, it sends back to client A the sequence number "1". It then sends to client B the op from client A.<p>On receiving the sequence number from the server, client A updates its refSeq to be 1.<p>Before client A's op has been sent to client B, client B sends its own op to the server. Client B receives client A's op and updates its refSeq to 1.<p>The server does the same thing for client B's op, and both client A and client B update their refSeq to 2.<p>This should hopefully start to make a bit of sense, but will become clearer once we talk about the internal representation of the merge-tree and go a bit more in depth on collaboration.<h2 id=internal-structure>Internal Structure</h2><p>Merge-tree represents a sequence as an ordered series of segments, with individual characters or elements being identified by the combination of a segment index and a character offset into that segment, referred to as "segoff." For example, if we take the string "abcde" and split it into arbitrary segments:<pre class=language-ts data-lang=ts style=background-color:#0f1419;color:#bfbab0;><code class=language-ts data-lang=ts><span>[</span><span style=color:#c2d94c;>"a"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"bcd"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"e"</span><span>]
</span></code></pre><p>The character "c" in the above string is at segment 1, offset 1. The character "e" is at segment 2, offset 0.<p>When the endpoints of an operation (like insertion or removal) fall within a segment, that segment is split. For example:<pre class=language-ts data-lang=ts style=background-color:#0f1419;color:#bfbab0;><code class=language-ts data-lang=ts><span>[</span><span style=color:#c2d94c;>"ae"</span><span>] </span><span style=color:#f29668;>-> </span><span>insert </span><span style=color:#c2d94c;>"bcd" </span><span>at position </span><span style=color:#f29718;>1 </span><span style=color:#f29668;>-> </span><span>[</span><span style=color:#c2d94c;>"a"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"bcd"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"e"</span><span>]
</span><span>[</span><span style=color:#c2d94c;>"abcde"</span><span>] </span><span style=color:#f29668;>-> </span><span>remove the range [</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>4</span><span>] </span><span style=color:#f29668;>-> </span><span>[</span><span style=color:#c2d94c;>"a"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"bcd"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"e"</span><span>] </span><span style=color:#f29668;>-> </span><span>[</span><span style=color:#c2d94c;>"a"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"e"</span><span>]
</span></code></pre><p>In order to map a numeric character position to a segoff, the merge-tree traverses the list of segments summing up the length of each segment until it lands inside one. Naively this list of segments can be modeled by a 2d-array, but in practice we represent this as a tree-like structure to efficiently traverse over large sections of the tree at once.<p>If we return back to the <code>["a", "bcd", "e"]</code> example, to get the segoff of the character at position 4 ("e"), we traverse the list of segments until we reach a segment that causes our cumulative length to exceed our position.<p>First we see "a" with a length of 1. Then we see "bcd" with a length of 3. Our cumulative length so far being 4. Because our characters are 0-indexed, we're actually looking for the character which causes length to become 5. So we resolve the character position 4 to the segoff <code>{ segment: "e", offset: 0 }</code>.<p>To get the full length of the string, we would traverse all segments like above, summing up their lengths.<h2 id=adding-basic-collaboration>Adding Basic Collaboration</h2><p>So far we haven't really motivated the reasons behind this array-of-segments structure. To do so, we have to make the segments more useful by adding more bookkeeping.<p>Merge-tree is able to simultaneously represent multiple different states by changing the visibility of segments. In practice, queries like "what is the character in this string at position 3" and "what is the full text of this string" are parameterized by both clientId and refSeq. These two parameters allow us to change the visibility of segments, and therefore see what the string would have looked like from the perspective of different clients at different points in time.<p>All segments have a <code>seq</code> property, which is the sequence number at which they were inserted. Segments also have a <code>removedSeq</code>, an optional sequence number denoting if and when the segment was removed.<p>Likewise, all segments have a <code>clientId</code> and <code>removedClientId</code> property, which denote the client that either inserted or removed the segment respectively.<p>Using these properties, and the properties from the op, the merge-tree can determine whether a given op would have been able to see a given segment.<p>The algorithm is this:<p>When processing a remote op -- i.e. an operation from another client -- that op is able to see all previous operations submitted by that remote client. That is, if <code>op.clientId === segment.clientId</code>, then the segment is visible to that operation during traversal.<p>Operations are also able to see all other operations that occurred before or at their refSeq. In code, we would say that all segments with <code>op.refSeq >= segment.seq</code> are visible.<p>The same is also true for <code>removedSeq</code> and <code>removedClientId</code>. If <code>op.clientId === segment.removedClientId</code>, then the segment is not visible, because it has been removed from the perspective of that client. Likewise all segments in which <code>op.refSeq > segment.removedSeq</code> are not visible during traversal.<p>This behavior is extremely powerful and is the basis for all conflict resolution and collaboration within merge-tree.<p>Let's look at an example merge-tree written out as json:<pre class=language-json data-lang=json style=background-color:#0f1419;color:#bfbab0;><code class=language-json data-lang=json><span>[
</span><span>    {
</span><span>        </span><span style=color:#c2d94c;>"seq"</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>,
</span><span>        </span><span style=color:#c2d94c;>"content"</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"ab"</span><span style=color:#bfbab0cc;>,
</span><span>        </span><span style=color:#c2d94c;>"clientId"</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"A"
</span><span>    }</span><span style=color:#bfbab0cc;>,
</span><span>    {
</span><span>        </span><span style=color:#c2d94c;>"seq"</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>3</span><span style=color:#bfbab0cc;>,
</span><span>        </span><span style=color:#c2d94c;>"content"</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"cd"</span><span style=color:#bfbab0cc;>,
</span><span>        </span><span style=color:#c2d94c;>"clientId"</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"B"
</span><span>    }</span><span style=color:#bfbab0cc;>,
</span><span>    {
</span><span>        </span><span style=color:#c2d94c;>"seq"</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>,
</span><span>        </span><span style=color:#c2d94c;>"content"</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"e"</span><span style=color:#bfbab0cc;>,
</span><span>        </span><span style=color:#c2d94c;>"clientId"</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"A"
</span><span>    }
</span><span>]
</span></code></pre><p>This is the string "abcde" with segments <code>["ab", "cd", "e"]</code>. Let's say at this point all clients ("A" and "B") have a refSeq of 3 and that the current seq is also 3.<p>If client A then inserts the character "X" at position 3, we get the string "abcXde" with segments <code>["ab", "c", "X", "d", "e"]</code>. Our segment "X" looks like:<pre class=language-json data-lang=json style=background-color:#0f1419;color:#bfbab0;><code class=language-json data-lang=json><span>{
</span><span>    </span><span style=color:#c2d94c;>"seq"</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>,
</span><span>    </span><span style=color:#c2d94c;>"content"</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"X"</span><span style=color:#bfbab0cc;>,
</span><span>    </span><span style=color:#c2d94c;>"clientId"</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"A"
</span><span>}
</span></code></pre><p>What would happen, though, if client B were to delete the character at position 4 ("d") concurrent to client A inserting the character "X"?<p>Let's say that the deletion operation reaches the server after the insertion operation. The insertion has seq of 4 and the deletion has seq of 5.<p>We'd like for our resulting string to be "abcXe". The character "X" was inserted between the "c" and the "d" from the perspective of client A, and the character "d" was deleted from the perspective of client B. When we combine these two operations, we want to keep "X" in relatively the same position and delete the same character ("d").<p>Our deletion op looks like this:<pre class=language-json data-lang=json style=background-color:#0f1419;color:#bfbab0;><code class=language-json data-lang=json><span>{
</span><span>    </span><span style=color:#c2d94c;>"op"</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"remove"</span><span style=color:#bfbab0cc;>,
</span><span>    </span><span style=color:#c2d94c;>"seq"</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>5</span><span style=color:#bfbab0cc;>,
</span><span>    </span><span style=color:#c2d94c;>"refSeq"</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>3</span><span style=color:#bfbab0cc;>,
</span><span>    </span><span style=color:#c2d94c;>"start"</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>3</span><span style=color:#bfbab0cc;>,
</span><span>    </span><span style=color:#c2d94c;>"end"</span><span style=color:#bfbab0cc;>: </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>, </span><span style=font-style:italic;color:#5c6773;>// (range end is exclusive, so does not include the character at position 4)
</span><span>    </span><span style=color:#c2d94c;>"clientId"</span><span style=color:#bfbab0cc;>: </span><span style=color:#c2d94c;>"B"
</span><span>}
</span></code></pre><p>I'll walk through an example of the algorithms I've described so far.<p>To start removing segments, we need to find which segments fall within the bounds of the remove, [3, 4). If either of those endpoints fall within a segment, that segment must be split. After splitting, we can do a depth-first tree traversal to find the start segment and then continue traversing until we reach the end segment.<p>Like before, we walk the segments summing up their length to determine when we reach a given position. In this case, we're looking for a start of 3 and an (exclusive) end of 4.<p>Again, our string consists of the segments <code>["ab", "c", "X", "d", "e"]</code>. We start with the segment "ab". This segment was inserted at seq 1, which is below our refSeq. It also has no removedSeq. This means that our deletion op knew about this segment, and so it is visible to us.<p>We can add its length of 2 to our running total. The next segment is "c", which has the same behavior and we can add its length of 1.<p>The next segment is "X", which was inserted by client A at seq 4. With a seq of 4, it was inserted after the refSeq (which is 3) of our remove op. This means the remove op is unaware of this segment, so we can skip it during this traversal.<p>The next segment is "d". This segment <em>is</em> visible to the deletion op, and adding its length to our running total puts us over the start position. Now we have our start segment and we can continue traversing the tree until we reach our end position.<p>In this case, that's pretty simple. We only have one segment to delete.<p>We can mark this segment removed by setting its removedSeq and removedClientId to the seq and client id of the op, 5 and "B" respectively.<p>All merge-tree ops follow this same pattern: find the position of an index in the tree and update some bookkeeping. In the case of remove and annotate, we change the properties of all the segments in a given range. In the case of insertion, we go to the insertion index, split the segment at that index if necessary, and do a tree insertion.<h2 id=local-edits>Local Edits</h2><p>If the merge-tree had to wait for an ack from the server every time it made a change, users would more than likely see very high latency between the op for the change being sent and the change being represented in the merge-tree. Especially in the case of multiple users editing the same merge-tree at once, seeing the results of a single edit might mean we need to process 100 ops from other clients before getting to our own.<p>The solution to this is to allow <strong>un-acked</strong> edits to the merge-tree which are used to create a local state that can be edited immediately and then reaffirmed once we receive an ack from the server.<p>To support local edits, the merge-tree needs additional bookkeeping to keep track of local-only changes. This comes firstly in the form of a <strong>local sequence number</strong> (localSeq). Much like a regular sequence number, this is a strictly increasing integer that uniquely identifies an operation; however, unlike a regular sequence number, a localSeq is unique to each client and lives completely in memory. localSeqs are not persisted anywhere, and exist only to manage the ephemeral state of local changes before they are <strong>acked</strong>.<p>Making use of this new local sequence number, segments contain additional bookkeeping the form of localSeq and localRemovedSeq. These are the local sequence numbers at which a segment was inserted or deleted respectively. If a segment has a local sequence number set, the corresponding <em>sequence number</em> is set to a sentinel value of -1. We call this special value the <strong>unassigned sequence number</strong>.<p>So if a segment has been removed, but that removal is yet unacked, that segment would have a removedSeq of -1 and a localRemovedSeq of whatever the localSeq was at the time of the op.<p>On ack, we are given a proper sequence number for a given local op. We must then traverse the merge-tree to find all the segments which have a local seq and convert their local seq to a proper sequence number. This would mean in our above example, setting the localRemovedSeq to <code>undefined</code> and setting the removedSeq of the sequence number we got back from the server.<p>In practice the merge-tree does additional bookkeeping to associate segments with local ops so that it does not need to traverse the entire tree to identify segments associated with a localSeq, but rather can just look the segments up in a dictionary and modify them all at once.<h2 id=reconnect-and-rebasing>Reconnect and Rebasing</h2><p>Sometimes users go offline but continue making edits. In this scenario, if the user comes back online we don't want to just throw away all the changes a user made while they were disconnected.<p>The solution for this in merge-tree is to rebase and resubmit all the operations that were created while offline. "Rebase" here is much like the rebasing you may be familiar with in git. We must first apply all the operations that were submitted by other clients while disconnected, updating the ops <em>we</em> submitted while doing so. Then, once these ops have been processed, we can resubmit our ops and hopefully preserve the offline changes.<h2 id=zamboni>Zamboni</h2><p>Over time, the merge-tree gets filled with a lot of cruft. This comes in two forms: tombstoned segments and fragmentation.<p>Removed segments are not immediately deleted from the merge-tree, but rather marked as removed and live in the tree as tombstones. In long running collaboration sessions, merge-trees can very easily end up with lots of superfluous tombstoned segments.<p>On terminology: here we use "removed" to mean deleted from the string from the perspective of the user, i.e. a segment is not visible, and "deleted" to mean that the segment is not in the string at all.<p>The other sort of cruft is inefficient segmentation or "fragmentation." This is where we use more segments than is necessary to represent a given string, for example <code>["a", "b", "c"]</code> vs <code>["abc"]</code>. Over time the merge-tree tends towards this more-segmented structure as more and more ops split the segments. Superfluous segments increase memory usage and the time it takes to walk the tree, as there are more segments to traverse.<p>During normal operation, the merge-tree needs these tombstoned and split segments to properly function, but there <em>is</em> a point in which this information becomes superfluous. Once all collaborating clients have seen a given insertion or deletion, we can safely delete a tombstoned segment or combine adjacent segments.<p>This process of cleaning up — or "garbage collecting" — the merge-tree is called <strong>zamboni</strong>. In real life, Zambonis clean the top layer of ice on an ice rink. Merge-tree has a similar process here where it cleans up the top (bottom?) layer of its segments incrementally.<p>This leads us into two concepts: the <strong>minimum sequence number</strong> (minSeq) and the <strong>collab(oration) window</strong>. The minimum sequence number is how merge-tree is able to know that all clients have seen a given change and represents the minimum of the refSeq of all the participating clients. The collab window is defined in terms of the minSeq, and refers to all the ops that occurred between the minSeq and the current highest sequence number from the server.<p>The minSeq is not tracked directly by the merge-tree, and is an implementation detail of the environment in which it runs.<p>When the server tells the merge-tree that the minSeq has advanced, it is free to do cleanup of these tombstoned and split segments.<p>The merge-tree keeps track of segments that need cleanup in a min-heap. For every operation (e.g. insert, remove, annotate), the merge-tree inserts into this min-heap the segments affected by that operation, keyed by the sequence number of that operation.<p>When the minSeq advances, the merge-tree is able to pop segments off of this heap to determine whether they are eligible for zamboni cleanup. If a segment was removed before the minSeq (in other words "outside the collab window"), then it can be safely deleted from the tree. Otherwise, if the segment was <em>inserted</em> prior to the minSeq, it can be safely combined with adjacent segments, assuming those segments have identical properties.<p>The concepts of a minSeq and collab window are a large part of what makes merge-tree both novel and efficient. Other, more-academic text editing algorithms rely on having the full edit history of the document persisted forever, while merge-tree is able to only keep exactly what is necessary.<p>There is a small caveat today that zamboni is less effective (perhaps aggressive is a better word) than it could be. The above algorithm also runs during <a href=https://connorskees.github.io/blog/merge-tree/#summarization>summarization</a>, though during summarization we run a much more aggressive algorithm, essentially settling on the optimal representation of a given merge-tree. Zamboni runs progressively as the minSeq updates and does not always produce the most optimal representation.<p>It should also be noted that the size (number of ops) of the collab window has a big impact on the performance of the merge-tree. Not only does a large collab window result in a lot of cruft that is unable to be cleaned up, there are a number of merge-tree algorithms that are O($$n^2$$) relative to the size of the collab window. Partial lengths updating, which we discuss below, is an example of such an algorithm.<h2 id=partial-lengths>Partial Lengths</h2><p><strong>Partial lengths</strong> are an optimization for quickly and efficiently calculating range length queries. Where a merge-tree is like a B+ tree that can represent many states simultaneously, I like to think of partial lengths as a similar structure based on <a href=https://cp-algorithms.com/data_structures/segment_tree.html>segment trees</a>.<p>Just like the merge-tree can answer queries like "what did the text of the string look like for this user at this point in time," partial lengths can answer queries like "what was the <em>length of this segment</em> for this user at this point in time?"<p>The goal for this data structure is to efficiently return the sum of the length of the child nodes given a refSeq and client id. By using partial lengths we can quickly skip over large sections of the tree by calculating their length from the perspective of our current operation.<p>Recall our example tree traversal above where we sum up segment lengths to reach our desired position. Partial lengths is the structure that allows us to speed up this traversal from O($$number of segments$$) to O($$log (number of segments)$$). This makes partial lengths critical to the efficient use of the merge-tree data structure.<h2 id=markers>Markers</h2><p>Merge-trees are not limited to working with text, and can support any kind of user-defined segment.<p><strong>Markers</strong> are a first-class segment with special behavior implemented by the merge-tree. They are 1-length segments that support accelerated queries for finding the next adjacent marker. Markers are most useful in text editing, where they make it easy to, for example, find the start of the next paragraph or next cell in a table.<p>This acceleration is implemented by keeping a sort of doubly linked list-like data structure with pointers stored on each parent node. Parent nodes are able to navigate to the left or right to find the next adjacent marker(s).<p>In the code today, this behavior is more generic than just applying to markers, with segments having this behavior being called "<strong>tiles</strong>." In practice, this behavior only applies to markers as of writing.<h2 id=reference-positions>Reference Positions</h2><p>Reference positions are similar to having pointers to individual characters in a string. As the contents of the string change, and the integer position of the character shifts around, the reference position will always point to the same character.<p>If that character is deleted, certain kinds of reference positions can slide to the next closest candidate character.<p>Reference positions are used to implement intervals, with the start and end positions of an interval being reference positions.<p>There is quite a bit of <a href=https://github.com/microsoft/FluidFramework/blob/7621baec8ef1ca0436d3429e5714317a281a40a7/packages/dds/merge-tree/docs/REFERENCEPOSITIONS.md>existing writing about reference positions</a>, so I will not talk too much about the different reference types or the core algorithms here.<h3 id=local-reference-positions>Local Reference Positions</h3><p>The concept of a reference position is an abstract interface that could in theory be implemented by a number of different structures to achieve myriad functionality.<p>In practice, there is only one kind of reference position<sup class=footnote-reference><a href=#2>2</a></sup>: a local reference position. Local reference positions are not sent across the wire and there is no op for creating one. They are purely local to the current client and are not persisted at any point.<p>"Local reference position" and "reference position" are today used interchangeably. The document linked in the section above discusses the behavior of local reference positions in more depth.<p>For use in intervals, the interval collection manages sending the position of local references to other clients and recreating such references locally when changes are received from other clients.<h2 id=ordinals>Ordinals</h2><p>Sometimes it's useful to be able to compare two segments and quickly determine the ordering of their position in the tree. For example, if you have a list of random segments and want to quickly sort them by their position in the tree.<p>The merge-tree attaches an "ordinal" to each segment. This is a unique string that is used in the ordering of segments. Ordinals can be thought of as arrays of bytes, though in practice we represent them as strings because <a href=https://stackoverflow.com/questions/8328908/javascript-surprising-array-comparison>comparison of arrays is hard in JavaScript</a>.<p>At each level of the tree we add a new byte to the array. Within a given level, the last byte increases as we move along the tree.<p>For example:<pre style=background-color:#0f1419;color:#bfbab0;><code><span>     "0"
</span><span>  /       \
</span><span>"00"      "01"
</span><span>       /   |   \
</span><span>   "010" "011" "012"
</span></code></pre><p>It's a bit annoying to get the ASCII diagram to look nice, but this should give a basic idea. Here, the nodes are what the ordinals would be at each segment. Then to compare if segment A comes in the string before segment B, we just have to compare <code>A.ordinal < B.ordinal</code>.<h2 id=summarization>Summarization</h2><p><strong>Summarization</strong> is the process by which the merge-tree is serialized so that it can be loaded later.<p>A lot of the summarization process can be considered an implementation detail best understood by reading the code, but I do wish to touch on a few interesting bits that aren't documented anywhere else, are useful to know, and are likely to remain true for some time.<p>Today the merge-tree supports two summarization formats: legacy and v1. The difference between the two is largely in the way operations that live inside the collab window are persisted.<p>The "legacy" format persists these ops literally and on load re-applies them. The v1 format eagerly applies these ops and persists the tree with them applied.<p>In the legacy format, the merge-tree will collect all the operations that occurred in the collab window (i.e. above the minSeq) and store them separately in an array called "catch up ops". All changes to segments that occurred past the minSeq are not persisted in this format. On load, these catch up ops are re-applied to the tree to get to the state at summarization.<p>In the v1 format, there is no such concept, and all segments are serialized exactly as they are in the tree at the point of summarization.<p>The SharedString data structure makes use of the "legacy" format, while the SharedMatrix data structure makes use of the v1 format.<p>There isn't a large reason to prefer one format over the other, and the distinction is largely for legacy reasons. Although one format is called "legacy," both formats are in active use and are supported -- the "legacy" name is a bit of a misnomer.<h2 id=aside-what-is-a-b-tree>Aside: What is a B-tree?</h2><p>B-trees and B+trees are admittedly more-niche data structures, so I think it may be helpful to quickly describe what they are. That the merge-tree is a B+tree is very much an implementation detail, and so it is not critical to understand these algorithms, but it may make some of the inner workings more clear.<p>You are likely already familiar with a BST or binary search tree. This is a tree data structure in which at each node values lesser than that node can be found by taking the left branch and values greater than the node can be found to the right.<p>A B-tree is exactly this data structure, except at each node instead of a single value, it contains a sorted array of values. This reduces the height of the tree, the number of unique allocations required, and improves the cache coherence of search and lookup.<p>A B+tree is a B-tree that does not store values in non-leaf nodes. So in a B+tree, all the elements in non-leaf nodes are pointers to other nodes. In a B-tree, the pointers to other nodes and values may be mixed in the node.<p>So merge-tree is a binary search tree where at each node there is either an array of pointers to child nodes, or in the case of leaf nodes there is an array of segments, as we described above.<h2 id=review-and-glossary>Review and Glossary</h2><p>The below is a quick summary of the vocabulary terms which are discussed in more detail above.<p><strong>sequence number</strong>: a strictly increasing integer assigned uniquely to all operations in the order they're processed by the server<p><strong>refSeq</strong>: the last sequence number from the server a particular client processed<p><strong>minSeq</strong>: the lowest reference sequence number (refSeq) of all clients viewing a document<p><strong>current seq</strong>: the highest (most recent) sequence number processed by the server<p><strong>collab window</strong>: all ops and sequence numbers between the minSeq and the current seq<p><strong>localSeq</strong>: a strictly increasing integer assigned uniquely to all <em>local</em> operations in the order they are created. is not sent over the wire or persisted anywhere<p><strong>unassigned sequence number</strong>: the placeholder/sentinel sequence number used for local edits when they have not been acked by the server, and so lack a proper sequence number<p><strong>ordinal</strong>: a string of bytes used to quickly determine relative ordering of two or more segments<p><strong>reference position</strong>: a pointer to an individual character in the string. slides to other characters if the character it points to is removed<p><strong>partial lengths</strong>: a segment tree-like optimization for quickly computing the length of nodes/segments in the merge-tree<p><strong>zamboni</strong>: merge-tree's garbage collection algorithm<p><strong>marker</strong>: special-cased 1-length segment that has no content itself and supports efficiently finding other markers<p><strong>tile</strong>: any segment having the spatially accelerated behavior of markers<p><strong>acked</strong>: an operation which has been sent to the server and given a sequence number<p><strong>unacked</strong>: an operation which has not yet been given a sequence number by the server<p><strong>client sequence number</strong>: a per-client sequence number used by the server to ensure data integrity and that all ops are processed in order. unused by merge-tree<div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>Technically sequence numbers of two ops <em>can</em> be the same in the case of grouped batching and grouped ops in general, but I think it's helpful to ignore these cases when discussing the core algorithms.</div><div class=footnote-definition id=2><sup class=footnote-definition-label>2</sup><p><a href=https://connorskees.github.io/blog/merge-tree/#markers>Markers</a> technically also implement the <code>ReferencePosition</code> interface, but this is largely legacy cruft and this functionality is not widely used today by merge-tree or its consumers.</div></section></article></main></div><script>window.addEventListener('load', function () {
            for (const ref of document.getElementsByClassName('footnote-reference')) {
                const hash = ref.children[0].hash.substring(1);
                const refhash = 'ref:' + hash;
                ref.id = refhash;
            }

            for (const footnote of document.getElementsByClassName('footnote-definition')) {
                const hash = footnote.id;
                const refhash = 'ref:' + hash;
                const backlink = document.createElement('a');
                backlink.href = '#' + refhash;
                backlink.className = 'footnote-backlink';
                backlink.innerText = '↩';
                const paras = footnote.children;
                const lastPara = paras[paras.length - 1];
                lastPara.appendChild(backlink);
            }
        });</script><script type=module>/*! instant.page v5.2.0 - (C) 2019-2023 Alexandre Dieulot - https://instant.page/license */
        let t, e, n, o, i, a = null, s = 65, c = new Set; const r = 1111; function d(t) { o = performance.now(); const e = t.target.closest("a"); m(e) && p(e.href, "high") } function u(t) { if (performance.now() - o < r) return; if (!("closest" in t.target)) return; const e = t.target.closest("a"); m(e) && (e.addEventListener("mouseout", f, { passive: !0 }), i = setTimeout(() => { p(e.href, "high"), i = void 0 }, s)) } function l(t) { const e = t.target.closest("a"); m(e) && p(e.href, "high") } function f(t) { t.relatedTarget && t.target.closest("a") == t.relatedTarget.closest("a") || i && (clearTimeout(i), i = void 0) } function h(t) { if (performance.now() - o < r) return; const e = t.target.closest("a"); if (t.which > 1 || t.metaKey || t.ctrlKey) return; if (!e) return; e.addEventListener("click", function (t) { 1337 != t.detail && t.preventDefault() }, { capture: !0, passive: !1, once: !0 }); const n = new MouseEvent("click", { view: window, bubbles: !0, cancelable: !1, detail: 1337 }); e.dispatchEvent(n) } function m(o) { if (o && o.href && (!n || "instant" in o.dataset)) { if (o.origin != location.origin) { if (!(e || "instant" in o.dataset) || !a) return } if (["http:", "https:"].includes(o.protocol) && ("http:" != o.protocol || "https:" != location.protocol) && (t || !o.search || "instant" in o.dataset) && !(o.hash && o.pathname + o.search == location.pathname + location.search || "noInstant" in o.dataset)) return !0 } } function p(t, e = "auto") { if (c.has(t)) return; const n = document.createElement("link"); n.rel = "prefetch", n.href = t, n.fetchPriority = e, n.as = "document", document.head.appendChild(n), c.add(t) } !function () { if (!document.createElement("link").relList.supports("prefetch")) return; const o = "instantVaryAccept" in document.body.dataset || "Shopify" in window, i = navigator.userAgent.indexOf("Chrome/"); i > -1 && (a = parseInt(navigator.userAgent.substring(i + "Chrome/".length))); if (o && a && a < 110) return; const c = "instantMousedownShortcut" in document.body.dataset; t = "instantAllowQueryString" in document.body.dataset, e = "instantAllowExternalLinks" in document.body.dataset, n = "instantWhitelist" in document.body.dataset; const r = { capture: !0, passive: !0 }; let f = !1, v = !1, g = !1; if ("instantIntensity" in document.body.dataset) { const t = document.body.dataset.instantIntensity; if (t.startsWith("mousedown")) f = !0, "mousedown-only" == t && (v = !0); else if (t.startsWith("viewport")) { const e = navigator.connection && navigator.connection.saveData, n = navigator.connection && navigator.connection.effectiveType && navigator.connection.effectiveType.includes("2g"); e || n || ("viewport" == t ? document.documentElement.clientWidth * document.documentElement.clientHeight < 45e4 && (g = !0) : "viewport-all" == t && (g = !0)) } else { const e = parseInt(t); isNaN(e) || (s = e) } } v || document.addEventListener("touchstart", d, r); f ? c || document.addEventListener("mousedown", l, r) : document.addEventListener("mouseover", u, r); c && document.addEventListener("mousedown", h, r); if (g) { let t = window.requestIdleCallback; t || (t = (t => { t() })), t(function () { const t = new IntersectionObserver(e => { e.forEach(e => { if (e.isIntersecting) { const n = e.target; t.unobserve(n), p(n.href) } }) }); document.querySelectorAll("a").forEach(e => { m(e) && t.observe(e) }) }, { timeout: 1500 }) } }();</script>