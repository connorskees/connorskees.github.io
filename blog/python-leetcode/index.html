<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title> Using Python for Leetcode </title><link href=https://connorskees.github.io/fonts.css rel=stylesheet><link href=https://connorskees.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://connorskees.github.io/theme/light.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@500&display=swap" rel=stylesheet><link href=https://connorskees.github.io/override.css rel=stylesheet><link href=https://connorskees.github.io/main.css media=screen rel=stylesheet><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script onload="renderMathInElement(document.body, { delimiters: [
                {left: '$$', right: '$$', display: false},
            ] });" crossorigin=anonymous defer integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js></script><body><script src="https://www.googletagmanager.com/gtag/js?id=G-R0T6WNHCFH" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-R0T6WNHCFH');</script><div class=content><header><div class=main><a href=https://connorskees.github.io></a><div class=socials><a class=social href=https://github.com/connorskees/> <object alt=github data=/social_icons/github.svg height=24 type=image/svg+xml width=24></object> </a></div></div><nav><a style="margin-left: 0.7em" href=/>Home</a></nav></header><main><article><div class=title><div class=page-header>Using Python for Leetcode</div><div class=meta>Posted on <time>2024-11-03</time></div></div><section class=body><p>After many technical interviews in a lot of different programming languages, I've decided that python is the best language for interviewing, and I would even go so far as to say that it's worth learning python even if only for interviewing.<p>Python is a lingua franca almost on the same tier as JavaScript, but has a much more robust standard library and set of syntactic sugar that makes it far easier to use when solving leetcode/interview problems. Some solutions can be a bit "magic," but in general are more readily understood by interviewers and lend themselves to being elegant and reading pretty close to English.<p>Below are some assorted tips to make python leetcode solutions nicer.<h2 id=looping>Looping</h2><h3 id=avoid-range-len-arr>Avoid <code>range(len(arr))</code></h3><p>Python uses exclusively <code>for .. in</code> loops, rather than the traditional C-style <code>for (int i = 0; i < arr.length; i++)</code> loops. If you have a loop that looks like<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span style=color:#ff7733;>for </span><span>i </span><span style=color:#ff7733;>in </span><span style=color:#f07178;>range</span><span>(</span><span style=color:#f07178;>len</span><span>(arr)):
</span><span>    elem </span><span style=color:#f29668;>= </span><span>arr[i]
</span><span>    </span><span style=color:#f07178;>print</span><span>(elem)
</span></code></pre><p>you should replace it with <code>for elem in arr</code>.<h3 id=if-you-do-need-the-index-use-enumerate>If you <em>do</em> need the index, use <code>enumerate(..)</code></h3><p><code>enumerate</code> takes a list and returns an iterator of tuples containing the elements alongside their indices. For example,<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span style=color:#ff7733;>for </span><span>idx</span><span style=color:#bfbab0cc;>, </span><span>elem </span><span style=color:#ff7733;>in </span><span style=color:#f07178;>enumerate</span><span>(arr):
</span><span>    </span><span style=color:#f07178;>print</span><span>(elem)
</span></code></pre><p>Remember the index is always the first element in the tuple. <code>enumerate</code> avoids ugly <code>range(len(..))</code> calls, and is useful in things like list comprehensions, which we'll discuss below.<h3 id=iterate-in-reverse-using-reversed>Iterate in reverse using <code>reversed(..)</code></h3><p>In a similar vein, you shouldn't use index-based loops to iterate in reverse. Sometimes people try to do <code>for i in range(len(arr) - 1, -1, -1)</code>. This is pretty ugly and annoying to type. Instead you should do<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span style=color:#ff7733;>for </span><span>elem </span><span style=color:#ff7733;>in </span><span style=color:#f07178;>reversed</span><span>(arr):
</span><span>    </span><span style=color:#f07178;>print</span><span>(elem)
</span></code></pre><h2 id=comprehensions>Comprehensions</h2><p>Python has syntactic sugar for <code>filter</code> and <code>map</code> in the form of "list comprehensions." Most people writing python are familiar with comprehensions, but there are some interesting applications that some may not know about.<h3 id=use-list-comprehensions-instead-of-map>Use list comprehensions instead of <code>map(..)</code></h3><p>A simple example might be to add <code>1</code> to every element in <code>arr</code>.<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>arr </span><span style=color:#f29668;>= </span><span>[elem </span><span style=color:#f29668;>+ </span><span style=color:#f29718;>1 </span><span style=color:#ff7733;>for </span><span>elem </span><span style=color:#ff7733;>in </span><span>arr]
</span></code></pre><p>List comprehensions make mappings over arrays easy to read and write.<h3 id=use-list-comprehensions-instead-of-filter>Use list comprehensions instead of <code>filter(..)</code></h3><p>List comprehensions also support filtering with the <code>if</code> keyword at the end. A simple example to keep only the even numbers in <code>arr</code>:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>arr </span><span style=color:#f29668;>= </span><span>[elem </span><span style=color:#ff7733;>for </span><span>elem </span><span style=color:#ff7733;>in </span><span>arr </span><span style=color:#ff7733;>if </span><span>elem </span><span style=color:#f29668;>% </span><span style=color:#f29718;>2 </span><span style=color:#f29668;>== </span><span style=color:#f29718;>0</span><span>]
</span></code></pre><p>Filtering and mapping can be combined to create arbitrarily complex expressions, though generally if your comprehension starts spanning over multiple lines, it might be good to split it up into multiple operations.<h3 id=set-and-dict-comprehensions>Set and dict comprehensions</h3><p>Comprehensions are not limited to constructing arrays. It's also possible to use them to easily create sets and dicts from existing collections.<p>For dictionary comprehensions, here's how you might create a dictionary which maps from an element to its index.<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>elem_to_idx </span><span style=color:#f29668;>= </span><span>{ elem</span><span style=color:#bfbab0cc;>: </span><span>idx </span><span style=color:#ff7733;>for </span><span>idx</span><span style=color:#bfbab0cc;>, </span><span>elem </span><span style=color:#ff7733;>in </span><span style=color:#f07178;>enumerate</span><span>(arr) }
</span></code></pre><p>Set comprehensions work in much the same way. Here's how you would create a set of just the even numbers in an array:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>unique_even_elems </span><span style=color:#f29668;>= </span><span>{ elem </span><span style=color:#ff7733;>for </span><span>elem </span><span style=color:#ff7733;>in </span><span>arr </span><span style=color:#ff7733;>if </span><span>elem </span><span style=color:#f29668;>% </span><span style=color:#f29718;>2 </span><span style=color:#f29668;>== </span><span style=color:#f29718;>0 </span><span>}
</span></code></pre><h3 id=you-can-also-create-generators-from-comprehensions>You can also create generators from comprehensions</h3><p>Though, generator comprehensions are less useful in leetcode problems.<p>Generators are lazy and will only yield elements when they're asked for explicitly using functions like <code>list(..)</code> or <code>next(..)</code>. This tends not to matter too much in interviews, but can be useful to 1. save characters when typing and 2. show off your knowledge of python and performance.<p>A generator expression uses parens instead of square brackets.<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>elems_generator </span><span style=color:#f29668;>= </span><span>(elem </span><span style=color:#ff7733;>for </span><span>elem </span><span style=color:#ff7733;>in </span><span>arr)
</span></code></pre><p>But the parens aren't necessary in contexts where they're already implied, for example as the only argument to a function. This can save typing a few characters for common stuff like <code>.join</code><pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>out </span><span style=color:#f29668;>= </span><span style=color:#c2d94c;>'-'</span><span style=color:#f29668;>.</span><span style=color:#ffb454;>join</span><span>(elem </span><span style=color:#ff7733;>for </span><span>elem </span><span style=color:#ff7733;>in </span><span>arr </span><span style=color:#ff7733;>if </span><span>elem </span><span style=color:#f29668;>% </span><span style=color:#f29718;>2 </span><span style=color:#f29668;>== </span><span style=color:#f29718;>0</span><span>)
</span></code></pre><h3 id=flattening-arrays-with-nested-comprehensions>Flattening arrays with nested comprehensions</h3><p>Flattening in python can actually be pretty annoying. The best way to do this is generally with a nested comprehension. In general the syntax of nested comprehensions can be confusing and easy to typo, so it's preferable to avoid them. But in the case of flattening it's not so bad. A single level flattening would look like:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>flat </span><span style=color:#f29668;>= </span><span>[elem </span><span style=color:#ff7733;>for </span><span>arr </span><span style=color:#ff7733;>in </span><span>nested_arr </span><span style=color:#ff7733;>for </span><span>elem </span><span style=color:#ff7733;>in </span><span>arr]
</span></code></pre><h2 id=repeating>Repeating</h2><h3 id=repeat-strings-with-multiplication>Repeat strings with multiplication</h3><p>To repeat the characters of a string <code>n</code> times in python, you just multiply the string by <code>n</code>. In other languages this is a bit more explicit with methods like <code>.repeat(..)</code>.<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span style=color:#c2d94c;>"a" </span><span style=color:#f29668;>* </span><span style=color:#f29718;>5 </span><span style=color:#f29668;>=> </span><span style=color:#c2d94c;>"aaaaa"
</span></code></pre><h3 id=repeat-list-contents-with-multiplication>Repeat list contents with multiplication</h3><p>Lists have a similar behavior, and can be multiplied to duplicate the contents.<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>[</span><span style=color:#c2d94c;>"a"</span><span>] </span><span style=color:#f29668;>* </span><span style=color:#f29718;>5 </span><span style=color:#f29668;>=> </span><span>[</span><span style=color:#c2d94c;>"a"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"a"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"a"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"a"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"a"</span><span>]
</span></code></pre><p><em>Use caution when multiplying lists which contain objects</em>. List multiplication does <em>not</em> copy the objects they contain. This means that something like <code>[[]] * 5</code> will not create 5 new lists, but rather create 5 new pointers pointing to the same underlying object. This is more clear with an example:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>arr </span><span style=color:#f29668;>= </span><span>[[]] </span><span style=color:#f29668;>* </span><span style=color:#f29718;>5 </span><span style=font-style:italic;color:#5c6773;># [[], [], [], [], []]
</span><span>arr[</span><span style=color:#f29718;>0</span><span>]</span><span style=color:#f29668;>.</span><span style=color:#ffb454;>append</span><span>(</span><span style=color:#c2d94c;>"a"</span><span>)
</span><span style=font-style:italic;color:#5c6773;># arr is now [['a'], ['a'], ['a'], ['a'], ['a']]
</span></code></pre><p>This behavior only matters for mutable objects, so most commonly lists and dicts. Immutable types like integers, strings, and tuples don't run into this issue, since they can't be modified in place.<p>The workaround for this behavior is to use a list comprehension,<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>arr </span><span style=color:#f29668;>= </span><span>[[] </span><span style=color:#ff7733;>for </span><span style=font-style:italic;color:#39bae6;>_ </span><span style=color:#ff7733;>in </span><span style=color:#f07178;>range</span><span>(</span><span style=color:#f29718;>5</span><span>)]
</span></code></pre><p>This can come up frequently in 2d array problems where you want to initialize a starting grid with each cell having a value like <code>0</code>.<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>grid </span><span style=color:#f29668;>= </span><span>[[</span><span style=color:#f29718;>0</span><span>] </span><span style=color:#f29668;>* </span><span>width </span><span style=color:#ff7733;>for </span><span style=font-style:italic;color:#39bae6;>_ </span><span style=color:#ff7733;>in </span><span style=color:#f07178;>range</span><span>(height)]
</span></code></pre><h2 id=indexing>Indexing</h2><h3 id=slice-ranges-from-lists-and-strings>Slice ranges from lists and strings</h3><p>This is another pretty basic python feature. You can slice the start and ends of lists and strings using the syntax <code>[start:end:step]</code>. All elements are optional. If not specified the values are <code>0</code>, <code>len(arr)</code>, and <code>1</code> (meaning no step/a contiguous range)<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>s </span><span style=color:#f29668;>= </span><span style=color:#c2d94c;>"12345"
</span><span>s[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>:</span><span style=color:#f29718;>3</span><span>]  </span><span style=font-style:italic;color:#5c6773;># "23"
</span><span>s[</span><span style=color:#bfbab0cc;>:</span><span style=color:#f29718;>3</span><span>]   </span><span style=font-style:italic;color:#5c6773;># "123"
</span><span>s[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>:</span><span>]   </span><span style=font-style:italic;color:#5c6773;># "2345"
</span><span>s[</span><span style=color:#bfbab0cc;>::</span><span style=color:#f29718;>2</span><span>]  </span><span style=font-style:italic;color:#5c6773;># "135"
</span><span>s[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>::</span><span style=color:#f29718;>2</span><span>] </span><span style=font-style:italic;color:#5c6773;># "24"
</span></code></pre><h3 id=negative-indices-for-indexing-the-end>Negative indices for indexing the end</h3><p>Python lists start at <code>0</code> and end at <code>-1</code>. This means in our string <code>s</code> of <code>"12345"</code>, <code>s[0]</code> is <code>1</code> and <code>s[-1]</code> is <code>5</code>. The negative indices count backwards from there, so <code>s[-2]</code> is <code>4</code> and so on.<p>This can make certain algorithms really elegant, though you have to watch out for subtle integer underflow bugs, which in other languages would throw an error for being out of bounds.<h3 id=negative-indices-in-slicing>Negative indices in slicing</h3><p>You can use negative indices combined with slicing to easily handle behavior at the end of the string.<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>s </span><span style=color:#f29668;>= </span><span style=color:#c2d94c;>"12345"
</span><span>s[</span><span style=color:#f29668;>-</span><span style=color:#f29718;>1</span><span>]  </span><span style=font-style:italic;color:#5c6773;># "5"
</span><span>s[</span><span style=color:#bfbab0cc;>:</span><span style=color:#f29668;>-</span><span style=color:#f29718;>1</span><span>] </span><span style=font-style:italic;color:#5c6773;># "1234"
</span><span>s[</span><span style=color:#f29668;>-</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>:</span><span>] </span><span style=font-style:italic;color:#5c6773;># "5"
</span><span>s[</span><span style=color:#f29668;>-</span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>:</span><span>] </span><span style=font-style:italic;color:#5c6773;># "45"
</span></code></pre><p>You can also use negative slicing to iterate in reverse. <code>s[::-1]</code> will actually reverse the string to make it <code>"54321"</code>.<h3 id=replacing-content-by-slicing>Replacing content by slicing</h3><p>Slicing in python generally creates a new array which is not related to the old one. For example,<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>a </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>3</span><span>]
</span><span>b </span><span style=color:#f29668;>= </span><span>a[</span><span style=color:#bfbab0cc;>:</span><span>]
</span><span>b[</span><span style=color:#f29718;>0</span><span>] </span><span style=color:#f29668;>= </span><span style=color:#f29718;>5
</span><span style=font-style:italic;color:#5c6773;># a => [1, 2, 3]
</span><span style=font-style:italic;color:#5c6773;># b => [5, 2, 3]
</span></code></pre><p>However, if you slice as part of the left hand side of an assignment, you can replace that slice with a new iterable. A pretty powerful aspect of this functionality is that the iterable being used to replace part of the original array doesn't need to be of the same length.<p>Here's an example of how you might reverse only the inner part of an array<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>arr </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>3</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>5</span><span>]
</span><span>arr[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>:</span><span style=color:#f29668;>-</span><span style=color:#f29718;>1</span><span>] </span><span style=color:#f29668;>= </span><span style=color:#f07178;>reversed</span><span>(arr[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>:</span><span style=color:#f29668;>-</span><span style=color:#f29718;>1</span><span>])
</span><span style=font-style:italic;color:#5c6773;># arr => [1, 4, 3, 2, 5]
</span></code></pre><p>Or deleting only the inner elements,<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>arr </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>3</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>5</span><span>]
</span><span>arr[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>:</span><span style=color:#f29668;>-</span><span style=color:#f29718;>1</span><span>] </span><span style=color:#f29668;>= </span><span>[]
</span><span style=font-style:italic;color:#5c6773;># arr => [1, 5]
</span></code></pre><h2 id=sorting>Sorting</h2><h3 id=sorting-with-sorted>Sorting with <code>sorted(..)</code></h3><p>Sorting in python is super simple, just call <code>sorted(..)</code> on the collection and it will return a list with the elements sorted.<h3 id=sorting-by-key>Sorting by key</h3><p>You can sort collections with a "key function" using the <code>key</code> parameter to <code>sorted(..)</code>. The key function just maps each element to a different value which is actually used for comparison. For example, here's how you could use the key function to sort the array such that all of the even numbers are at the start:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>arr </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>3</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>4</span><span>]
</span><span style=color:#f07178;>sorted</span><span>(arr</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>key</span><span style=color:#f29668;>=</span><span style=color:#ff7733;>lambda </span><span style=color:#f29718;>elem</span><span>: elem </span><span style=color:#f29668;>% </span><span style=color:#f29718;>2</span><span>) </span><span style=font-style:italic;color:#5c6773;># [2, 4, 1, 3]
</span></code></pre><p>I also want to give a special shoutout to sorting by len, <code>sorted(arr, key=len)</code>, or by other properties which python already has builtin functions for looking up.<h3 id=sorting-in-reverse>Sorting in reverse</h3><p><code>sorted(..)</code> also takes a <code>reverse</code> parameter, which can invert the sort. <code>sorted(arr, reverse=True)</code>. This can be combined with a key function. Keep in mind this parameter has a different name from the builtin function<h3 id=sorting-with-a-custom-comparison-function>Sorting with a custom comparison function</h3><p>Please don't sort using a custom comparison function. A custom comparison function is where you define a function that takes in two values and returns <code>-1</code>, <code>0</code>, or <code>1</code> depending on which value is greater. These are generally easy to typo and much more complex than sorting with a key. There is effectively no leetcode question where it would be better to sort this way than with a key.<p>In some special cases where you really do need a comparison function, you can use <code>functools.cmp_to_key</code> function to convert the comparison function to a key function.<h3 id=min-and-max>Min and max</h3><p>Python has global functions <code>min</code> and <code>max</code> which can be used to do exactly what it sounds like. If passed a single iterable as an argument they will find the minimum/maximum element in that collection, and if passed multiple arguments they will find the min/max value among those arguments. If you want to find the min/max value among the elements of several lists, you'll want to spread those lists as arguments, which is discussed more below.<p><code>min</code> and <code>max</code> also accept a <code>key=</code> argument, which behaves in the same way that it does for <code>sorted</code>.<h2 id=unpacking-and-spreading>Unpacking and Spreading</h2><h3 id=iterator-unpacking>Iterator unpacking</h3><p>Python supports list unpacking. This is also called destructuring in other languages like JavaScript. This allows you to remove repeated array lookups like <code>first = arr[0]</code>, <code>second = arr[1]</code>, etc. It actually works with all iterators, including things like tuples, sets, and generators. However, most commonly you will see this with arrays and tuples.<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>first, second, third </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>3</span><span>]
</span></code></pre><p>This will crash if the iterator isn't exactly 3 elements in size. If your array is more than 3 elements and you just want to slice off the first few elements, you can also have a <code>*arg</code>.<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>first, second, </span><span style=color:#f29668;>*</span><span>rest </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>3</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>5</span><span>]
</span><span style=font-style:italic;color:#5c6773;># first = 1
</span><span style=font-style:italic;color:#5c6773;># second = 2
</span><span style=font-style:italic;color:#5c6773;># rest = [3, 4, 5]
</span></code></pre><h3 id=variable-swapping-with-unpacking>Variable swapping with unpacking</h3><p>Unpacking can also be used to swap variables without a temporary variable.<p>Bad:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>tmp </span><span style=color:#f29668;>= </span><span>a
</span><span>a </span><span style=color:#f29668;>= </span><span>b
</span><span>b </span><span style=color:#f29668;>= </span><span>tmp
</span></code></pre><p>Good:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>a, b </span><span style=color:#f29668;>= </span><span>b, a
</span></code></pre><p>You can also use this for the pretty common pattern in some leetcode questions of having two variables, <code>a</code> and <code>b</code>, and needing to set <code>a</code> to <code>b</code> and <code>b</code> to a new value.<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span style=color:#ff7733;>def </span><span style=color:#ffb454;>fib</span><span>(</span><span style=color:#f29718;>n</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#39bae6;>int</span><span>) </span><span style=color:#bfbab0cc;>-> </span><span style=font-style:italic;color:#39bae6;>int</span><span>:
</span><span>    a, b </span><span style=color:#f29668;>= </span><span style=color:#f29718;>0</span><span>, </span><span style=color:#f29718;>1
</span><span>    </span><span style=color:#ff7733;>for </span><span style=font-style:italic;color:#39bae6;>_ </span><span style=color:#ff7733;>in </span><span style=color:#f07178;>range</span><span>(n):
</span><span>        a, b </span><span style=color:#f29668;>= </span><span>b, a </span><span style=color:#f29668;>+ </span><span>b
</span><span>    </span><span style=color:#ff7733;>return </span><span>a
</span></code></pre><p>This is a pretty simple way to implement computing the nth fibonacci number.<h3 id=spreading>Spreading</h3><p>Python supports first class syntax for spreading iterators into function arguments and other collections. This can also be useful for flattening lists.<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>a </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#f29718;>1</span><span>]
</span><span>[</span><span style=color:#f29668;>*</span><span>a</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29668;>*</span><span>[</span><span style=color:#f29718;>2</span><span>]] </span><span style=font-style:italic;color:#5c6773;># [1, 2]
</span></code></pre><p>This also works for function arguments, for example <code>min</code><pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span style=color:#f07178;>min</span><span>([</span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>1</span><span>]</span><span style=color:#bfbab0cc;>, </span><span>[</span><span style=color:#f29718;>3</span><span>]) </span><span style=font-style:italic;color:#5c6773;># [3]
</span><span style=color:#f07178;>min</span><span>(</span><span style=color:#f29668;>*</span><span>[</span><span style=color:#f29718;>4</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>1</span><span>]</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29668;>*</span><span>[</span><span style=color:#f29718;>3</span><span>]) </span><span style=font-style:italic;color:#5c6773;># 1
</span></code></pre><h2 id=collections>Collections</h2><p>Python's standard library of collections is one of the main reasons I like it so much for interviews<h3 id=collection-construction-using-set-list-dict>Collection construction using <code>set(..)</code>, <code>list(..)</code>, <code>dict(..)</code></h3><p>This is a bit basic, but I sometimes see solutions which manually <code>.append(..)</code> or <code>.add(..)</code> inside of a loop to convert from a list to a set or vice-versa. Converting collections in python is really simple,<p>Bad:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>arr </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>1</span><span>]
</span><span>unique </span><span style=color:#f29668;>= </span><span style=font-style:italic;color:#39bae6;>set</span><span>()
</span><span>
</span><span style=color:#ff7733;>for </span><span>elem </span><span style=color:#ff7733;>in </span><span>arr:
</span><span>    unique</span><span style=color:#f29668;>.</span><span style=color:#ffb454;>add</span><span>(elem)
</span></code></pre><p>Good:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>arr </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>1</span><span>]
</span><span>unique </span><span style=color:#f29668;>= </span><span style=font-style:italic;color:#39bae6;>set</span><span>(arr)
</span></code></pre><p>Dicts can be created in this way, as long as the elements are lists/tuples/other iterators containing exactly two elements. So something like <code>dict([("key", "value"), ("a", "b")])</code>. This can be combined with <code>zip(..)</code> to easily combine two lists into a <code>key: value</code> dict:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>keys </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span>]
</span><span>values </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#c2d94c;>"a"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"b"</span><span style=color:#bfbab0cc;>, </span><span style=color:#c2d94c;>"c"</span><span>]
</span><span>
</span><span>combined </span><span style=color:#f29668;>= </span><span style=font-style:italic;color:#39bae6;>dict</span><span>(</span><span style=color:#f07178;>zip</span><span>(keys</span><span style=color:#bfbab0cc;>, </span><span>values)) </span><span style=font-style:italic;color:#5c6773;># { 0: "a", 1: "b", 2: "c" }
</span></code></pre><h3 id=union-and-intersection-of-sets>Union and intersection of sets</h3><p>Python sets support unioning and intersecting using <code>|</code> and <code>&</code> respectively.<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span style=font-style:italic;color:#39bae6;>set</span><span>([</span><span style=color:#f29718;>1</span><span>]) </span><span style=color:#f29668;>| </span><span style=font-style:italic;color:#39bae6;>set</span><span>([</span><span style=color:#f29718;>2</span><span>]) </span><span style=font-style:italic;color:#5c6773;># { 1, 2 }
</span><span style=font-style:italic;color:#39bae6;>set</span><span>([</span><span style=color:#f29718;>1</span><span>]) </span><span style=color:#f29668;>& </span><span style=font-style:italic;color:#39bae6;>set</span><span>([</span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span>]) </span><span style=font-style:italic;color:#5c6773;># { 1 }
</span></code></pre><p>It's also possible to take the union of two dictionaries this way, though you can't intersect them. If the dictionaries share keys when unioning, the resulting dictionary will have the value of the right hand dict.<h3 id=difference-of-sets>Difference of sets</h3><p>Sets also support computing the difference with subtraction, and the symmetric difference with <code>^</code> (xor). If you subtract set <code>a</code> by set <code>b</code>, all elements in <code>b</code> will be removed from <code>a</code>. And if you xor <code>a</code> and <code>b</code>, you'll get a set which contains the elements that are only in <em>either</em> <code>a</code> or <code>b</code> but not both:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>a </span><span style=color:#f29668;>= </span><span>{ </span><span style=color:#f29718;>1</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>3 </span><span>}
</span><span>b </span><span style=color:#f29668;>= </span><span>{ </span><span style=color:#f29718;>2</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>3</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>4 </span><span>}
</span><span>
</span><span>a </span><span style=color:#f29668;>- </span><span>b </span><span style=font-style:italic;color:#5c6773;># { 1 }
</span><span>b </span><span style=color:#f29668;>- </span><span>a </span><span style=font-style:italic;color:#5c6773;># { 4 }
</span><span>a </span><span style=color:#f29668;>^ </span><span>b </span><span style=font-style:italic;color:#5c6773;># { 1, 4 }
</span></code></pre><h3 id=defaultdict><code>defaultdict</code></h3><p><code>defaultdict</code> is a collection from python's <code>collections</code> module, and it's a dictionary which has a default value for missing keys. This property can be really helpful in leetcode problems when you want to avoid nesting due to checking the base case.<p>You set the default value for the keys using a function passed into the constructor.<p>Bad:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>elem_counts </span><span style=color:#f29668;>= </span><span>{}
</span><span>
</span><span style=color:#ff7733;>for </span><span>elem </span><span style=color:#ff7733;>in </span><span>arr:
</span><span>    </span><span style=color:#ff7733;>if </span><span>elem </span><span style=color:#f29668;>in </span><span>elem_counts:
</span><span>        elem_counts[elem] </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>1
</span><span>    </span><span style=color:#ff7733;>else</span><span>:
</span><span>        elem_counts[elem] </span><span style=color:#f29668;>= </span><span style=color:#f29718;>1
</span></code></pre><p>Good:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>elem_counts </span><span style=color:#f29668;>= </span><span style=color:#ffb454;>defaultdict</span><span>(</span><span style=color:#ff7733;>lambda</span><span>: </span><span style=color:#f29718;>0</span><span>) </span><span style=font-style:italic;color:#5c6773;># default value of 0
</span><span>
</span><span style=color:#ff7733;>for </span><span>elem </span><span style=color:#ff7733;>in </span><span>arr:
</span><span>    elem_counts[elem] </span><span style=color:#f29668;>+= </span><span style=color:#f29718;>1
</span></code></pre><p><code>defaultdict</code> is one of my favorite data structures, and I end up using it more often than regular dictionaries in leetcode problems. A pro tip is that you can specify the name of the data type you want as the constructor to get the default value, so <code>defaultdict(int)</code> is the same as <code>defaultdict(lambda: 0)</code>, and <code>defaultdict(list)</code> is the same as <code>lambda: []</code>.<h3 id=deque><code>deque</code></h3><p>A less interesting collection, also from the <code>collections</code> module. This is a standard double-ended queue and can pop of the front or back with <code>popleft(..)</code> and <code>pop(..)</code> respectively, with a similar behavior for <code>.appendleft(..)</code> and <code>.append(..)</code>.<h3 id=counter><code>Counter</code></h3><p><code>Counter</code> is another utility collection from the <code>collections</code> module. It's a pretty basic structure that's more or less a dictionary which maps elements to their number of occurrences. For example, <code>Counter("aabc")</code> would give us <code>{ "a": 2, "b": 1, "c": 1 }</code>. <code>Counter</code> is a bit cooler than just a dictionary because you can add and subtract them and the counts for individual elements will combine, rather than clobbering each other.<p>For example, <code>Counter("aabc") + Counter("abd")</code> would give us <code>{ "a": 3, "b": 2, "c": 1, "d": 1 }</code>.<p>Another cool property is that <code>Counter</code> behaves pretty similarly to <code>defaultdict</code>: looking up the count for a value which isn't in the dictionary will always return <code>0</code>.<p>I've used this in interviews to, for example, compute the most frequent character in a string and to compute the number of characters that would need to be inserted into two strings to make them equal.<h3 id=hashing-with-tuples>Hashing with tuples</h3><p>In python, lists and other objects can't be used as keys to hash maps/sets. This can be pretty annoying when trying to deduplicate lists or other common operations involving hash maps, like creating a cache over a 2d grid using <code>[x, y]</code> coords.<p>Tuples, however, <em>can</em> be used as keys to hash maps/sets. Converting a list to a tuple is pretty simple: <code>tuple(arr)</code>.<h3 id=heaps-with-heapq>Heaps with <code>heapq</code></h3><p>The <code>heapq</code> module allows you to rearrange the elements in an array such that they are ordered like a binary heap. This doesn't change the class of the list, it only changes the order of elements.<p>To convert to a heap, <code>heapq.heapify(arr)</code> will modify the array in place so that it can be used as a heap. Remember that you don't need to do this if the array is empty or only contains a single element. Sometimes I see code that looks like this,<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>heap </span><span style=color:#f29668;>= </span><span>[]
</span><span>heapq</span><span style=color:#f29668;>.</span><span style=color:#ffb454;>heapify</span><span>(heap)
</span></code></pre><p>which is entirely superfluous.<p>A cool trick is that the smallest value will be at <code>arr[0]</code>, so you can peek at this value without popping.<p>To pop and push, <code>heapq.heappop(arr)</code> and <code>heapq.heappush(arr, elem)</code>. There's also <code>heapq.heappushpop(arr, elem)</code> that's a bit faster if you want to push and then pop at the same, though this is pretty rare.<h4 id=min-and-max-heaps>Min and max heaps</h4><p>Python's <code>heapq</code> module, like a lot of other languages, only supports min heaps. In order to implement a max heap, in which you always pop off the largest elements, we need to modify the values we insert into the heap.<p>For numbers, this is pretty easy. We just always negate the value before inserting into the heap, and after looking up from the heap. For example:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>heap </span><span style=color:#f29668;>= </span><span>[]
</span><span>
</span><span>heapq</span><span style=color:#f29668;>.</span><span style=color:#ffb454;>heappush</span><span>(</span><span style=color:#f29668;>-</span><span>a)
</span><span>
</span><span style=font-style:italic;color:#5c6773;># ...
</span><span>
</span><span>val </span><span style=color:#f29668;>= -</span><span>heapq</span><span style=color:#f29668;>.</span><span style=color:#ffb454;>heappop</span><span>(heap)
</span></code></pre><p>To use a max heap for other data structures, you can either find some way of negating the comparison, like taking the negative of an array of integers, or by writing a custom class which overrides the <code>></code> and <code><</code> operators.<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span style=color:#ff7733;>class </span><span style=color:#59c2ff;>ReversedCompareString</span><span>:
</span><span>    </span><span style=color:#ff7733;>def </span><span style=color:#f07178;>__init__</span><span>(</span><span style=color:#f29718;>self</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>s</span><span>):
</span><span>        </span><span style=font-style:italic;color:#39bae6;>self</span><span style=color:#f29668;>.</span><span>s </span><span style=color:#f29668;>= </span><span>s
</span><span>
</span><span>    </span><span style=color:#ff7733;>def </span><span style=color:#f07178;>__lt__</span><span>(</span><span style=color:#f29718;>self</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>rhs</span><span>):
</span><span>        </span><span style=color:#ff7733;>return </span><span style=font-style:italic;color:#39bae6;>self</span><span style=color:#f29668;>.</span><span>s </span><span style=color:#f29668;>> </span><span>rhs</span><span style=color:#f29668;>.</span><span>s
</span><span>
</span><span>    </span><span style=color:#ff7733;>def </span><span style=color:#f07178;>__eq__</span><span>(</span><span style=color:#f29718;>self</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>rhs</span><span>):
</span><span>        </span><span style=color:#ff7733;>return </span><span style=font-style:italic;color:#39bae6;>self</span><span style=color:#f29668;>.</span><span>s </span><span style=color:#f29668;>== </span><span>rhs</span><span style=color:#f29668;>.</span><span>s
</span></code></pre><p>Then you can wrap and unwrap strings in this data structure when inserting and popping out of the heap.<h2 id=utilities>Utilities</h2><h3 id=binary-search-with-bisect>Binary search with <code>bisect</code></h3><p>Python's standard library contains utilities for doing binary search, so you don't have to worry about implementing it yourself. Binary search can be pretty off-by-one and typo prone, so this is pretty nice.<p><code>bisect.bisect_left(arr, elem)</code> will return the leftmost index of the elem in the arr if it exists, and otherwise will return the index of where the element should go. There's also <code>bisect.bisect_right(..)</code> which will return the position to the right of the rightmost element in the arr if it exists, and otherwise has the same behavior as <code>bisect_left</code>. Usually <code>bisect_left</code> is what you want.<p><code>bisect.bisect_left</code> also supports a <code>key=</code> argument, in the same way that sorting does.<h3 id=easy-memoization-with-functools-cache-and-functools-lru-cache>Easy memoization with <code>@functools.cache</code> and <code>@functools.lru_cache</code></h3><p>Caching is a pretty common pattern in dynamic programming problems. You have a function which gets called recusively with some parameters, and a cache hashmap which you insert the parameter and return value into.<p><code>@functools.cache</code> is a decorator that implements this caching for you in just a single line of code. It works like this:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span style=color:#bfbab0cc;>@</span><span>functools</span><span style=color:#f29668;>.</span><span style=color:#ffb454;>cache
</span><span style=color:#ff7733;>def </span><span style=color:#ffb454;>is_even</span><span>(</span><span style=color:#f29718;>n</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#39bae6;>int</span><span>) </span><span style=color:#bfbab0cc;>-> </span><span style=font-style:italic;color:#39bae6;>bool</span><span>:
</span><span>    </span><span style=color:#ff7733;>return </span><span>n </span><span style=color:#f29668;>% </span><span style=color:#f29718;>2 </span><span style=color:#f29668;>== </span><span style=color:#f29718;>0
</span></code></pre><p>Subsequent calls to the <code>is_even</code> function will lookup the <code>n</code> parameter in the cache to see if the result has already been computed.<p>For some problems, the cache can end up getting really large and causing memory issues. This generally means that your implementation has a bug (try calling the function less, or reducing the number of parameters the function takes in), but it's also one that can often be solved without changing the implementation. Instead of a cache which never evicts keys, you can use an <code>@functools.lru_cache</code> to have keys automatically evicted when the cache goes above a certain size.<p>By default the max cache size is 128, but can be configured to be higher with the <code>max_size</code> parameter,<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span style=color:#bfbab0cc;>@</span><span>functools</span><span style=color:#f29668;>.</span><span style=color:#ffb454;>lru_cache</span><span>(</span><span style=color:#f29718;>maxsize</span><span style=color:#f29668;>=</span><span style=color:#f29718;>2 </span><span style=color:#f29668;>** </span><span style=color:#f29718;>9</span><span>)
</span><span style=color:#ff7733;>def </span><span style=color:#ffb454;>is_even</span><span>(</span><span style=color:#f29718;>n</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#39bae6;>int</span><span>) </span><span style=color:#bfbab0cc;>-> </span><span style=font-style:italic;color:#39bae6;>bool</span><span>:
</span><span>    </span><span style=color:#ff7733;>return </span><span>n </span><span style=color:#f29668;>% </span><span style=color:#f29718;>2 </span><span style=color:#f29668;>== </span><span style=color:#f29718;>0
</span></code></pre><p>Note that <code>maxsize</code> doesn't have an underscore.<p>You also tend to get bonus points from interviewers for mentioning the potentially bad memory consequences of using <code>@cache</code>.<h3 id=prefix-sum-1-liner>Prefix sum 1-liner</h3><p>There are a bunch of ways in python to compute the prefix sum of an array. If you want to save on characters: <code>prefix_sum = [0, *itertools.accumulate(nums)]</code>.<p>Otherwise, I often do:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span>prefix_sum </span><span style=color:#f29668;>= </span><span>[</span><span style=color:#f29718;>0</span><span>]
</span><span>
</span><span style=color:#ff7733;>for </span><span>num </span><span style=color:#ff7733;>in </span><span>nums:
</span><span>    prefix_sum</span><span style=color:#f29668;>.</span><span style=color:#ffb454;>append</span><span>(prefix_sum[</span><span style=color:#f29668;>-</span><span style=color:#f29718;>1</span><span>] </span><span style=color:#f29668;>+ </span><span>num)
</span></code></pre><p>I think both work fine, and I may lean towards the latter during an interview, but the former during a leetcode contest.<h2 id=misc-tips>Misc Tips</h2><h3 id=reminding-yourself-with-static-types>Reminding yourself with static types</h3><p>Modern versions of python support pretty robust optional static typing. These types are ignored at runtime, but can be useful if you're coming from a strongly-typed language for helping to lay out your thoughts. Writing down the function signature and noting that it returns an int or a bool or an array can be really helpful in not getting off track and returning the wrong value. For example if the function asks for the top 2 values, but you misread it and go to return only the max value, the interviewer would be able to stop you when you confirm the return type of <code>int</code> rather than <code>list[int]</code>/<code>tuple[int, int]</code>.<p>Using static types in python also generally tends to impress interviewers, and demonstrates a good understanding of the language. Python static typing supports pretty complex behavior like generics, literals, and dependent types, but generally just knowing the how to type the base builtin types like <code>str</code>, <code>int</code>, <code>list[..]</code>, <code>tuple[..]</code>, and <code>dict[..]</code> is more than enough.<h3 id=sentinel-values-with-math-inf>Sentinel values with <code>math.inf</code></h3><p>In a lot of algorithms, you start out with the min/max value being the maximum/minimum possible representable value. In python this can be done trivially using <code>math.inf</code> and <code>-math.inf</code>.<h3 id=my-boilerplate-for-tries>My boilerplate for tries</h3><p>Tries are a niche data structure that come up in some string problems. I have only really seen them in leetcode hards and bonus questions on OAs.<p>I start with a <code>TrieNode</code> class, which makes up the trie:<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span style=color:#ff7733;>class </span><span style=color:#59c2ff;>TrieNode</span><span>:
</span><span>    </span><span style=color:#ff7733;>def </span><span style=color:#f07178;>__init__</span><span>(</span><span style=color:#f29718;>self</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>c</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#39bae6;>str</span><span>):
</span><span>        </span><span style=font-style:italic;color:#39bae6;>self</span><span style=color:#f29668;>.</span><span>c </span><span style=color:#f29668;>= </span><span>c
</span><span>        </span><span style=font-style:italic;color:#39bae6;>self</span><span style=color:#f29668;>.</span><span>children</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#39bae6;>dict</span><span>[</span><span style=font-style:italic;color:#39bae6;>str</span><span>, </span><span style=font-style:italic;color:#39bae6;>list</span><span>[TrieNode]] </span><span style=color:#f29668;>= </span><span>{}
</span><span>        </span><span style=font-style:italic;color:#39bae6;>self</span><span style=color:#f29668;>.</span><span>is_end </span><span style=color:#f29668;>= </span><span style=color:#f29718;>False
</span></code></pre><p>A trie node represents a single character (in this case <code>c</code>), and connects that character to others. <code>children</code> is a mapping from character to a list of trie nodes. <code>is_end</code> is true when this node is the last character in a string. <code>is_end</code> doesn't mean that the node can't have any children, just that some string ended here. A case where <code>is_end</code> is true but the node still has children is <code>["a", "ab"]</code>.<p>Often <code>TrieNode</code> needs to be given more fields to more optimally solve a particular problem. For example, if you wanted to count how many strings have a given prefix, you might modify <code>TrieNode</code> to contain a count which keeps track of the number of strings that use the node.<p>Then I declare a <code>Trie</code> class to serve as the root of the trie and expose an API.<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span style=color:#ff7733;>class </span><span style=color:#59c2ff;>Trie</span><span>:
</span><span>    </span><span style=color:#ff7733;>def </span><span style=color:#f07178;>__init__</span><span>(</span><span style=color:#f29718;>self</span><span>):
</span><span>        </span><span style=font-style:italic;color:#39bae6;>self</span><span style=color:#f29668;>.</span><span>root </span><span style=color:#f29668;>= </span><span style=color:#ffb454;>TrieNode</span><span>(</span><span style=color:#c2d94c;>""</span><span>)
</span></code></pre><p>Most trie problems start by inserting a dictionary of words into the trie. The algorithm for adding a string to the trie is<pre class=language-py data-lang=py style=background-color:#0f1419;color:#bfbab0;><code class=language-py data-lang=py><span style=color:#ff7733;>def </span><span style=color:#ffb454;>add</span><span>(</span><span style=color:#f29718;>self</span><span style=color:#bfbab0cc;>, </span><span style=color:#f29718;>s</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#39bae6;>str</span><span>):
</span><span>    root </span><span style=color:#f29668;>= </span><span style=font-style:italic;color:#39bae6;>self</span><span style=color:#f29668;>.</span><span>root
</span><span>
</span><span>    </span><span style=color:#ff7733;>for </span><span>c </span><span style=color:#ff7733;>in </span><span>s:
</span><span>        </span><span style=color:#ff7733;>if </span><span>c </span><span style=color:#f29668;>not in </span><span>root</span><span style=color:#f29668;>.</span><span>children:
</span><span>            root</span><span style=color:#f29668;>.</span><span>children[c] </span><span style=color:#f29668;>= </span><span style=color:#ffb454;>TrieNode</span><span>(c)
</span><span>        root </span><span style=color:#f29668;>= </span><span>root</span><span style=color:#f29668;>.</span><span>children[c]
</span><span>
</span><span>    root</span><span style=color:#f29668;>.</span><span>is_end </span><span style=color:#f29668;>= </span><span style=color:#f29718;>True
</span></code></pre></section></article></main></div><script>window.addEventListener('load', function () {
            for (const ref of document.getElementsByClassName('footnote-reference')) {
                const hash = ref.children[0].hash.substring(1);
                const refhash = 'ref:' + hash;
                ref.id = refhash;
            }

            for (const footnote of document.getElementsByClassName('footnote-definition')) {
                const hash = footnote.id;
                const refhash = 'ref:' + hash;
                const backlink = document.createElement('a');
                backlink.href = '#' + refhash;
                backlink.className = 'footnote-backlink';
                backlink.innerText = '↩';
                const paras = footnote.children;
                const lastPara = paras[paras.length - 1];
                lastPara.appendChild(backlink);
            }
        });</script><script type=module>/*! instant.page v5.2.0 - (C) 2019-2023 Alexandre Dieulot - https://instant.page/license */
        let t, e, n, o, i, a = null, s = 65, c = new Set; const r = 1111; function d(t) { o = performance.now(); const e = t.target.closest("a"); m(e) && p(e.href, "high") } function u(t) { if (performance.now() - o < r) return; if (!("closest" in t.target)) return; const e = t.target.closest("a"); m(e) && (e.addEventListener("mouseout", f, { passive: !0 }), i = setTimeout(() => { p(e.href, "high"), i = void 0 }, s)) } function l(t) { const e = t.target.closest("a"); m(e) && p(e.href, "high") } function f(t) { t.relatedTarget && t.target.closest("a") == t.relatedTarget.closest("a") || i && (clearTimeout(i), i = void 0) } function h(t) { if (performance.now() - o < r) return; const e = t.target.closest("a"); if (t.which > 1 || t.metaKey || t.ctrlKey) return; if (!e) return; e.addEventListener("click", function (t) { 1337 != t.detail && t.preventDefault() }, { capture: !0, passive: !1, once: !0 }); const n = new MouseEvent("click", { view: window, bubbles: !0, cancelable: !1, detail: 1337 }); e.dispatchEvent(n) } function m(o) { if (o && o.href && (!n || "instant" in o.dataset)) { if (o.origin != location.origin) { if (!(e || "instant" in o.dataset) || !a) return } if (["http:", "https:"].includes(o.protocol) && ("http:" != o.protocol || "https:" != location.protocol) && (t || !o.search || "instant" in o.dataset) && !(o.hash && o.pathname + o.search == location.pathname + location.search || "noInstant" in o.dataset)) return !0 } } function p(t, e = "auto") { if (c.has(t)) return; const n = document.createElement("link"); n.rel = "prefetch", n.href = t, n.fetchPriority = e, n.as = "document", document.head.appendChild(n), c.add(t) } !function () { if (!document.createElement("link").relList.supports("prefetch")) return; const o = "instantVaryAccept" in document.body.dataset || "Shopify" in window, i = navigator.userAgent.indexOf("Chrome/"); i > -1 && (a = parseInt(navigator.userAgent.substring(i + "Chrome/".length))); if (o && a && a < 110) return; const c = "instantMousedownShortcut" in document.body.dataset; t = "instantAllowQueryString" in document.body.dataset, e = "instantAllowExternalLinks" in document.body.dataset, n = "instantWhitelist" in document.body.dataset; const r = { capture: !0, passive: !0 }; let f = !1, v = !1, g = !1; if ("instantIntensity" in document.body.dataset) { const t = document.body.dataset.instantIntensity; if (t.startsWith("mousedown")) f = !0, "mousedown-only" == t && (v = !0); else if (t.startsWith("viewport")) { const e = navigator.connection && navigator.connection.saveData, n = navigator.connection && navigator.connection.effectiveType && navigator.connection.effectiveType.includes("2g"); e || n || ("viewport" == t ? document.documentElement.clientWidth * document.documentElement.clientHeight < 45e4 && (g = !0) : "viewport-all" == t && (g = !0)) } else { const e = parseInt(t); isNaN(e) || (s = e) } } v || document.addEventListener("touchstart", d, r); f ? c || document.addEventListener("mousedown", l, r) : document.addEventListener("mouseover", u, r); c && document.addEventListener("mousedown", h, r); if (g) { let t = window.requestIdleCallback; t || (t = (t => { t() })), t(function () { const t = new IntersectionObserver(e => { e.forEach(e => { if (e.isIntersecting) { const n = e.target; t.unobserve(n), p(n.href) } }) }); document.querySelectorAll("a").forEach(e => { m(e) && t.observe(e) }) }, { timeout: 1500 }) } }();</script>