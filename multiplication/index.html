<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title> Multiplication Algorithms </title><link href=https://connorskees.github.io/fonts.css rel=stylesheet><link href=https://connorskees.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://connorskees.github.io/theme/light.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@500&display=swap" rel=stylesheet><link href=https://connorskees.github.io/override.css rel=stylesheet><link href=https://connorskees.github.io/main.css media=screen rel=stylesheet><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script onload="renderMathInElement(document.body, { delimiters: [
                {left: '$$', right: '$$', display: false},
            ] });" crossorigin=anonymous defer integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js></script><body><script src="https://www.googletagmanager.com/gtag/js?id=G-R0T6WNHCFH" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-R0T6WNHCFH');</script><div class=content><header><div class=main><a href=https://connorskees.github.io></a><div class=socials><a class=social href=https://github.com/connorskees/> <object alt=github data=/social_icons/github.svg height=24 type=image/svg+xml width=24></object> </a></div></div><nav><a style="margin-left: 0.7em" href=/>Home</a></nav></header><main><article><div class=title><div class=page-header>Multiplication Algorithms</div><div class=meta></div></div><section class=body><p>I'm intimidated by modern mathematical algorithms, like those used for <a href=https://arxiv.org/abs/2101.11408>float parsing</a> and <a href=https://dl.acm.org/doi/10.1145/3192366.3192369>formatting</a>, or famously the <a href="https://www.youtube.com/watch?v=p8u_k2LIZyo">inverse square root</a>.<p>I do love math, but it often feels like these algorithms are unapproachable to casual understanding. That is, effectively understanding the intuition behind these algorithms requires a lot of pre-requisite reading of logic- and notation-dense papers.<p>I don't necessarily have the time or mathematical background to dig into the existing literature for a lot of these algorithms. But recently, I've been interested in algorithms for multiplication, after hearing that some bigint libraries rely on the fast Fourier transform to perform multiplication in some scenarios.<p>The below is what I hope to be the most comprehensive overview of modern multiplication algorithms with explanations written in plain English.<h1 id=integers>Integers</h1><h2 id=looping>Looping</h2><p>Fundamentally multiplication describes successive additions. If we say <code>x * 2</code>, we can expand this as <code>x + x</code>. Similarly, <code>x * 4</code> is the same as <code>x + x + x + x</code>.<p>The easiest way to implement this in code would be a <code>for</code> loop:<pre class=language-rust data-lang=rust style=background-color:#0f1419;color:#bfbab0;><code class=language-rust data-lang=rust><span style=color:#ff7733;>fn </span><span style=color:#ffb454;>multiply</span><span>(</span><span style=color:#f29718;>multiplicand</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>i32</span><span>, </span><span style=color:#f29718;>multiplier</span><span style=color:#bfbab0cc;>: </span><span style=color:#ff7733;>i32</span><span>) </span><span style=color:#bfbab0cc;>-> </span><span style=color:#ff7733;>i32 </span><span>{
</span><span>    </span><span style=color:#ff7733;>let mut</span><span> product </span><span style=color:#f29668;>= </span><span style=color:#f29718;>0</span><span style=color:#bfbab0cc;>;
</span><span>    
</span><span>    </span><span style=color:#ff7733;>for </span><span style=color:#f29668;>_ in </span><span style=color:#f29718;>0</span><span style=color:#f29668;>..</span><span>multiplier {
</span><span>        product </span><span style=color:#f29668;>+=</span><span> multiplicand</span><span style=color:#bfbab0cc;>;
</span><span>    }
</span><span>
</span><span>    product
</span><span>}
</span></code></pre><p>We loop <code>multiplier</code> times, adding <code>multiplicand</code> to the total product each time. For right now we're ignoring complexities like overflow.<p>For small multipliers, this doesn't seem so bad. However, as our multiplier grows, the number of additions we have to perform grows similarly. In the worst case scenario, if our muliplier is <code>u32::MAX</code>, we'd be performing over 4 billion additions -- this is pretty slow.<p>Ideally our algorithm wouldn't scale with the value of our multiplier, but rather the scale. That is, our algorithm would get slower relative to the number of digits used to represent the number, not the actual value it contains.<h2 id=long-multiplication>Long Multiplication</h2><p>Long multiplication solves the problem of scaling relative to the number of digits.<p>It's also likely the way you were taught in school to multiply two numbers. If we look at a simple base-10 example:<pre style=background-color:#0f1419;color:#bfbab0;><code><span>  25
</span><span>*  7
</span><span>----
</span></code></pre><p>We multiply all individual digits and then sum them up:<pre style=background-color:#0f1419;color:#bfbab0;><code><span>20 * 7 + 5 * 7 = 140 + 35 = 175
</span></code></pre><p>If our multiplier has two digits:<pre style=background-color:#0f1419;color:#bfbab0;><code><span>       25
</span><span>*      34
</span><span>---------
</span><span>    4 * 5
</span><span>+  4 * 20
</span><span>+  30 * 5
</span><span>+ 30 * 20
</span><span>---------
</span><span>       20
</span><span>+      80
</span><span>+     150
</span><span>+     600
</span><span>---------
</span><span>      850
</span></code></pre><p>We end up performing 4 additions and multiplications.<p>Long multiplication has a time complexity of O(n<sup>2</sup>), and so it isn't really suitable for extremely large numbers. You may also be familiar with other methods for doing multiplication by hand; in general, these are all also O(n<sup>2</sup>).<p>Although this algorithm is quadratic, it also is quite simple to implement and has a pretty low constant factor. This makes it suitable -- and even optimal -- for small (say, <=64 bit) integers. This algorithm forms the basis of most hardware implementations of multiplication, as we'll discuss <a href=https://connorskees.github.io/multiplication/#hardware-algorithms>later in this post</a>.<h2 id=karatsuba-1962>Karatsuba (1962)</h2><p>Anatoly Karatsuba's algorithm for multiplication was the first to break the O(n<sup>2</sup>) complexity barrier. Previously it had been conjectured that no algorithm could do better than O(n<sup>2</sup>).<p>Karatsuba is a recursive divide and conquer algorithm.<p>If we split our multiplication up into multiple separate multiplications, we can re-use some of the intermediate results.<p>The algorithm starts by splitting our multiplicand and multiplier in half, getting four numbers total. For example, we would split the number <code>23</code> into <code>20 + 3</code>, or the number <code>123456</code> into <code>123000 + 456</code>.<p>More formally: given a number of <code>n</code> digits, we split it into two numbers <code>a</code> and <code>b</code> such that our original number is equal to $$a \times 10^{\frac{n}{2}} + b$$.<p>Let's look at a multiplication of two numbers, <code>x</code> and <code>y</code>. Using the splitting idea we just mentioned,<p>$$ x = a + b $$</p><br> $$ y = c + d $$ <p>This is the same equation used above, but for our multiplier <code>y</code> we use the variables <code>c</code> and <code>d</code>. If we substitute these values into our $$x \times y$$ equation, we get<p>$$ x \times y = (a + b)(c + d) $$<p>If we distribute everything out:<p>$$ x \times y = (a \times 10^{\frac{n}{2}}) \times (c \times 10^{\frac{n}{2}}) + (ad \times 10^{\frac{n}{2}}) + (bc \times 10^{\frac{n}{2}}) + bd $$<p>Simplifying:<p>$$ x \times y = ac \times 10^{n} + (ad + bc) \times 10^{\frac{n}{2}} + bd $$<h2 id=toom-cook>Toom–Cook</h2><p>The Toom–Cook algorithm is a generalization of Karatsuba multiplication. Where Karatsuba multiplication splits a number into 2 constituent parts, Toom–Cook splits the number into a potentially arbitrary number of parts. Though, most commonly you'll see 3 parts (Toom 3) or 4 parts (Toom 4). Karatsuba, in this way, can also be thought of as Toom 2. Regular long multiplication is Toom 1.<h2 id=schonhage-strassen-1971>Schönhage–Strassen (1971)</h2><p>Schönhage–Strassen is also sometimes called "FFT multiplication," as the core optimization of this algorithm is that it uses the fast Fourier transform to achieve O($$n \log n \log \log n$$) runtime.<p>Schönhage–Strassen works by splitting the multiplier and multiplicand, similar to Karatsuba, and constructs two polynomials with the decomposed integers as coeffecients. It can then make use of <a href=http://www.cs.toronto.edu/~denisp/csc373/docs/tutorial3-adv-writeup.pdf>existing algorithms to multiply two polynomials in O($$n \log n$$)</a> time.<p>To understand this algorithm more concretely, we first have to understand Fourier transforms, the fast Fourier transform, and some abstract algebra.<h2 id=furer-2007>Fürer (2007)</h2><ul><li>paper: https://ivv5hpp.uni-muenster.de/u/cl/WS2007-8/mult.pdf<li>https://ir.lib.uwo.ca/cgi/viewcontent.cgi?article=7368&context=etd</ul><h2 id=de-kurur-saha-saptharishi-2008>De–Kurur–Saha–Saptharishi (2008)</h2><ul><li>https://arxiv.org/abs/0801.1416</ul><h2 id=harvey-van-der-hoeven-lecerf-2014>Harvey–van der Hoeven–Lecerf (2014)</h2><ul><li>https://arxiv.org/abs/1407.3361</ul><h2 id=covanov-thome-2015>Covanov–Thomé (2015)</h2><ul><li>https://arxiv.org/abs/1502.02800</ul><h2 id=harvey-van-der-hoeven-2019>Harvey–van der Hoeven (2019)</h2><ul><li>https://annals.math.princeton.edu/2021/193-2/p04<li>https://hal.science/hal-02070778v2/document</ul><h1 id=reals>Reals</h1><h2 id=floats>Floats</h2><h2 id=fixed-point>Fixed point</h2><h1 id=hardware-algorithms>Hardware Algorithms</h1><p>One of the simpler and faster ways to multiply two numbers on modern computers is:<pre class=language-asm data-lang=asm style=background-color:#0f1419;color:#bfbab0;><code class=language-asm data-lang=asm><span style=color:#ff7733;>mov </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>25
</span><span style=color:#ff7733;>mul </span><span style=color:#f29718;>rax</span><span>, </span><span style=color:#f29718;>34
</span><span style=font-style:italic;color:#5c6773;>; rax = 850
</span></code></pre><h2 id=shift-add>Shift + Add</h2><h2 id=modified-baugh-wooley>Modified Baugh-Wooley</h2><h2 id=booth-1950>Booth (1950)</h2><h2 id=wallace-trees-1964>Wallace Trees (1964)</h2><h2 id=dadda-multiplier-1965>Dadda Multiplier (1965)</h2><h1 id=modular-multiplication>Modular Multiplication</h1><h2 id=kochanski>Kochanski</h2><h2 id=montgomery>Montgomery</h2><h1 id=floats-1>Floats</h1><p>https://github.com/microsoft/referencesource/blob/master/System.Numerics/System/Numerics/BigIntegerBuilder.cs https://github.com/rust-num/num-bigint/blob/f09eee83f174619ac9c2489e3feec62544984bc5/src/biguint/multiplication.rs#L95</section></article></main></div><script>window.addEventListener('load', function () {
            for (const ref of document.getElementsByClassName('footnote-reference')) {
                const hash = ref.children[0].hash.substring(1);
                const refhash = 'ref:' + hash;
                ref.id = refhash;
            }

            for (const footnote of document.getElementsByClassName('footnote-definition')) {
                const hash = footnote.id;
                const refhash = 'ref:' + hash;
                const backlink = document.createElement('a');
                backlink.href = '#' + refhash;
                backlink.className = 'footnote-backlink';
                backlink.innerText = '↩';
                const paras = footnote.children;
                const lastPara = paras[paras.length - 1];
                lastPara.appendChild(backlink);
            }
        });</script><script type=module>/*! instant.page v5.2.0 - (C) 2019-2023 Alexandre Dieulot - https://instant.page/license */
        let t, e, n, o, i, a = null, s = 65, c = new Set; const r = 1111; function d(t) { o = performance.now(); const e = t.target.closest("a"); m(e) && p(e.href, "high") } function u(t) { if (performance.now() - o < r) return; if (!("closest" in t.target)) return; const e = t.target.closest("a"); m(e) && (e.addEventListener("mouseout", f, { passive: !0 }), i = setTimeout(() => { p(e.href, "high"), i = void 0 }, s)) } function l(t) { const e = t.target.closest("a"); m(e) && p(e.href, "high") } function f(t) { t.relatedTarget && t.target.closest("a") == t.relatedTarget.closest("a") || i && (clearTimeout(i), i = void 0) } function h(t) { if (performance.now() - o < r) return; const e = t.target.closest("a"); if (t.which > 1 || t.metaKey || t.ctrlKey) return; if (!e) return; e.addEventListener("click", function (t) { 1337 != t.detail && t.preventDefault() }, { capture: !0, passive: !1, once: !0 }); const n = new MouseEvent("click", { view: window, bubbles: !0, cancelable: !1, detail: 1337 }); e.dispatchEvent(n) } function m(o) { if (o && o.href && (!n || "instant" in o.dataset)) { if (o.origin != location.origin) { if (!(e || "instant" in o.dataset) || !a) return } if (["http:", "https:"].includes(o.protocol) && ("http:" != o.protocol || "https:" != location.protocol) && (t || !o.search || "instant" in o.dataset) && !(o.hash && o.pathname + o.search == location.pathname + location.search || "noInstant" in o.dataset)) return !0 } } function p(t, e = "auto") { if (c.has(t)) return; const n = document.createElement("link"); n.rel = "prefetch", n.href = t, n.fetchPriority = e, n.as = "document", document.head.appendChild(n), c.add(t) } !function () { if (!document.createElement("link").relList.supports("prefetch")) return; const o = "instantVaryAccept" in document.body.dataset || "Shopify" in window, i = navigator.userAgent.indexOf("Chrome/"); i > -1 && (a = parseInt(navigator.userAgent.substring(i + "Chrome/".length))); if (o && a && a < 110) return; const c = "instantMousedownShortcut" in document.body.dataset; t = "instantAllowQueryString" in document.body.dataset, e = "instantAllowExternalLinks" in document.body.dataset, n = "instantWhitelist" in document.body.dataset; const r = { capture: !0, passive: !0 }; let f = !1, v = !1, g = !1; if ("instantIntensity" in document.body.dataset) { const t = document.body.dataset.instantIntensity; if (t.startsWith("mousedown")) f = !0, "mousedown-only" == t && (v = !0); else if (t.startsWith("viewport")) { const e = navigator.connection && navigator.connection.saveData, n = navigator.connection && navigator.connection.effectiveType && navigator.connection.effectiveType.includes("2g"); e || n || ("viewport" == t ? document.documentElement.clientWidth * document.documentElement.clientHeight < 45e4 && (g = !0) : "viewport-all" == t && (g = !0)) } else { const e = parseInt(t); isNaN(e) || (s = e) } } v || document.addEventListener("touchstart", d, r); f ? c || document.addEventListener("mousedown", l, r) : document.addEventListener("mouseover", u, r); c && document.addEventListener("mousedown", h, r); if (g) { let t = window.requestIdleCallback; t || (t = (t => { t() })), t(function () { const t = new IntersectionObserver(e => { e.forEach(e => { if (e.isIntersecting) { const n = e.target; t.unobserve(n), p(n.href) } }) }); document.querySelectorAll("a").forEach(e => { m(e) && t.observe(e) }) }, { timeout: 1500 }) } }();</script>