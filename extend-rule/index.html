<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title> Understanding `@extend` </title><link href=https://connorskees.github.io/fonts.css rel=stylesheet><link href=https://connorskees.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://connorskees.github.io/theme/light.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@500&display=swap" rel=stylesheet><link href=https://connorskees.github.io/override.css rel=stylesheet><link href=https://connorskees.github.io/main.css media=screen rel=stylesheet><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script onload="renderMathInElement(document.body, { delimiters: [
                {left: '$$', right: '$$', display: false},
            ] });" crossorigin=anonymous defer integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js></script><body><script src="https://www.googletagmanager.com/gtag/js?id=G-R0T6WNHCFH" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-R0T6WNHCFH');</script><div class=content><header><div class=main><a href=https://connorskees.github.io></a><div class=socials><a class=social href=https://github.com/connorskees/> <object alt=github data=/social_icons/github.svg height=24 type=image/svg+xml width=24></object> </a></div></div><nav><a style="margin-left: 0.7em" href=/>Home</a></nav></header><main><article><div class=title><div class=page-header>Understanding `@extend`</div><div class=meta></div></div><section class=body><p><code>@extend</code> is a special rule in Sass that makes it easier to write base classes. Where in regular CSS you might have an element with the classes <code>"button button--error"</code>, using <code>@extend</code> you can reduce duplication by creating a base class <code>%button</code> and having <code>.button--error</code> extend it. This results in simpler code and smaller bundle sizes.<p>The implementation of <code>@extend</code> is surprisingly complex. It's by far one of the hardest parts of Sass compilation. A naive implementation wouldn't be <em>too</em> hard, but the production implementation of <code>@extend</code> has been around <a href=https://github.com/sass/ruby-sass/commit/f918cf3c397b1b463752af3f8780028d5dbaea80>since 2010</a> and over time has adopted a number of features, constraints, and optimizations. Sass tries its hardest to produce the smallest number of selectors possible, which is a non-trivial problem.<p>This post goes through a high level overview of the algorithms behind <code>@extend</code>. An understanding of Sass is not necessary, but some familiarity with HTML and CSS is expected.<p>I'll walk through a high level description of the primitives necessary to implement <code>@extend</code>, and then explain how they can be combined together to get the final algorithm. The general outline of this is:<h4 id=anatomy-of-a-selector>Anatomy of a Selector</h4><p>The first primitive necessary to understand <code>@extend</code> is the CSS selector. Selector lists are composed of a series of complex selectors, which are themselves composed of compound selectors, and which finally are composed of simple selectors.<p>Simple selectors are the base atoms of a CSS selector. In Sass, they can be either:<ul><li>id <code>#foo</code><li>class <code>.foo</code><li>attribute <code>[foo]</code>, with one of 6 operators (<code>[foo$=bar]</code>, etc.)<li>type <code>foo</code>, with an optional namespace. these are also sometimes called element selectors<li>pseudo (class and element) <code>:hover</code>/<code>::before</code><li>universal <code>*</code>, with an optional namespace<li>the parent selector <code>&</code><li>placeholder <code>%foo</code></ul><p>If you're familiar with CSS, the first 6 should already be familiar. The last 2 might only make sense if you're used to Sass. The parent selector, as the name implies, refers to the selector of the parent style rule. A selector will have a parent if it's <a href=https://sass-lang.com/documentation/style-rules/#nesting>nested inside another rule</a>. If the style rule is at the root, then this is <code>null</code>. Parent selectors are resolved prior to extension, so they're not necessary to understand <code>@extend</code>.<p>The placeholder selector is special in that it gets removed during compilation and will not show up in the resulting CSS. This is useful when combined with <code>@extend</code>, as it allows for the creation of base classes that can be extended but not show up in the CSS.<p>Compound selectors are composed of 1 or more simple selectors not separated by any other characters. They operate as an "and." For example, <code>.bar.foo</code> is a compound selector containing two simple class selectors, <code>.bar</code> and <code>.foo</code>. This selector will only match elements that have both classes.<p>Complex selectors are composed of 1 or more compound selectors joined together by combinators. Valid combinators are descendant (<code> </code>), next sibling (<code>+</code>), child (<code>></code>), and following sibling (<code>~</code>). The semantics of these are relevant to some parts of extend, and can be found in the <a href=https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors/Combinators>MDN docs</a>.<p>Finally, selector lists are composed of 1 or more comma separated complex selectors.<p>A bit more verbose phrasing of this can be found in the <a href=https://drafts.csswg.org/selectors-4/#syntax>CSS spec</a>. Sass, being a superset of CSS, inherits much of its syntax from the CSS spec.<h4 id=anatomy-of-a-single-extend>Anatomy of a Single Extend</h4><p>Extension can be thought of as a function that takes three arguments: the extendee, the extender, and the target. The extendee and extender are selector lists. The target is a simple selector.<p>When we apply extension from the extender to the extendee, we look for all instances of the target and intelligently replace the target with the extender such that the extender takes on the same semantics of the target.<p>This phrasing is a bit dense, so let's look at a simple example of an extend:<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>a </span><span>{ </span><span style=font-style:italic;color:#5c6773;>// extendee
</span><span>    </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#f29668;>red</span><span style=color:#bfbab0cc;>;
</span><span>}
</span><span>
</span><span style=color:#59c2ff;>b </span><span>{ </span><span style=font-style:italic;color:#5c6773;>// extender
</span><span>    </span><span style=color:#ff7733;>@extend </span><span style=color:#59c2ff;>a</span><span style=color:#bfbab0cc;>;  </span><span style=font-style:italic;color:#5c6773;>// target
</span><span>}
</span></code></pre><p>In this case, our extendee is <code>a</code>, our extender is <code>b</code>, and our target is <code>a</code>.<p>If we compile this:<pre class=language-css data-lang=css style=background-color:#0f1419;color:#bfbab0;><code class=language-css data-lang=css><span style=color:#59c2ff;>a</span><span style=color:#bfbab0cc;>, </span><span style=color:#59c2ff;>b </span><span>{
</span><span>  </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#f29668;>red</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>We end up with a selector that matches both our extendee <code>a</code> and our extender <code>b</code>. This is pretty straightforward. Let's see what happens when we try extending a compound selector,<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>a</span><span>:hover {
</span><span>    </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#f29668;>red</span><span style=color:#bfbab0cc;>;
</span><span>}
</span><span>
</span><span style=color:#59c2ff;>b </span><span>{
</span><span>    </span><span style=color:#ff7733;>@extend </span><span style=color:#59c2ff;>a</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>Here, our extendee is <code>a:hover</code>, our extender is <code>b</code>, and our target is <code>a</code>.<p>Our result is<pre class=language-css data-lang=css style=background-color:#0f1419;color:#bfbab0;><code class=language-css data-lang=css><span style=color:#59c2ff;>a</span><span>:hover</span><span style=color:#bfbab0cc;>, </span><span style=color:#59c2ff;>b</span><span>:hover {
</span><span>  </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#f29668;>red</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>which translates the semantics of <code>a:hover</code> to our extender <code>b</code>.<p>Things get a bit more interesting if we try extending complex selectors,<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>a a </span><span>{
</span><span>    </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#f29668;>red</span><span style=color:#bfbab0cc;>;
</span><span>}
</span><span>
</span><span style=color:#59c2ff;>b </span><span>{
</span><span>    </span><span style=color:#ff7733;>@extend </span><span style=color:#59c2ff;>a</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>Here, our extendee is <code>a a</code>, our extender is <code>b</code>, and our target is <code>a</code>. This example is interesting because now we're extending a selector that has multiple instances of our target. How does Sass handle this?<pre class=language-css data-lang=css style=background-color:#0f1419;color:#bfbab0;><code class=language-css data-lang=css><span style=color:#59c2ff;>a a</span><span style=color:#bfbab0cc;>, </span><span style=color:#59c2ff;>b a</span><span style=color:#bfbab0cc;>, </span><span style=color:#59c2ff;>a b</span><span style=color:#bfbab0cc;>, </span><span style=color:#59c2ff;>b b </span><span>{
</span><span>  </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#f29668;>red</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>A combinatorial explosion. We generate all possible combinations of <code>a</code> and <code>b</code>. If we try making our extendee the character <code>a</code> repeated 15 times, we end up with over a megabyte in just selectors for our output. But, it does accurately translate the semantics of every instance of our target <code>a</code> to our extender <code>b</code>.<p>Let's look at an example of extending a selector list to see what we mean by "intelligently replaces." This will be the last example we look at for now.<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>a</span><span style=color:#bfbab0cc;>, </span><span style=color:#59c2ff;>b </span><span>{
</span><span>    </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#f29668;>red</span><span style=color:#bfbab0cc;>;
</span><span>}
</span><span>
</span><span style=color:#59c2ff;>b </span><span>{
</span><span>    </span><span style=color:#ff7733;>@extend </span><span style=color:#59c2ff;>a</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>Here, our extendee is <code>a, b</code>, our extender is <code>b</code>, and our target is <code>a</code>. This case is interesting because our extendee already has the semantics for our extender that we would want. How does Sass handle this?<pre class=language-css data-lang=css style=background-color:#0f1419;color:#bfbab0;><code class=language-css data-lang=css><span style=color:#59c2ff;>a</span><span style=color:#bfbab0cc;>, </span><span style=color:#59c2ff;>b </span><span>{
</span><span>  </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#f29668;>red</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>Sass is smart and doesn't generate any redundant selectors here. Though, the way this is happening under the hood is that the redundant selector <em>is</em> generated, it's just trimmed out during a separate pass. We'll discuss this later on.<h4 id=superselectors>Superselectors</h4><p>Our next primitive is the concept of a superselector and a subselector. If you're familiar with <a href=https://doc.rust-lang.org/nomicon/subtyping.html>subtyping in other programming languages</a>, the vocabulary should be a bit familiar.<p>Selector <code>A</code> is a superselector of selector <code>B</code> if it matches at least all elements that <code>B</code> matches. <code>B</code> would then be considered a subselector of <code>A</code>.<p>Let's walk through a couple examples. We'll define a function, <code>is-superselector</code> that takes 2 selectors and returns whether the first selector is a superselector of the second.<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>is-superselector</span><span>("</span><span style=color:#59c2ff;>a</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#59c2ff;>a</span><span>")
</span><span style=font-style:italic;color:#5c6773;>// true
</span></code></pre><p>All selectors are superselectors of themselves. This should be pretty intuitive -- <code>a</code> matches all elements that are matched by <code>a</code>.<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>is-superselector</span><span>("</span><span style=color:#59c2ff;>a</span><span style=color:#ffb454;>.foo</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#59c2ff;>a</span><span>")
</span><span style=font-style:italic;color:#5c6773;>// false
</span></code></pre><p><code>a.foo</code> isn't a superselector of <code>a</code>, because it only matches <code>a</code> elements that have the class <code>foo</code>. But if we switch the arguments around,<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>is-superselector</span><span>("</span><span style=color:#59c2ff;>a</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#59c2ff;>a</span><span style=color:#ffb454;>.foo</span><span>")
</span><span style=font-style:italic;color:#5c6773;>// true
</span></code></pre><p><code>a</code> <em>is</em> a superselector of <code>a.foo</code> because it matches all the elements that <code>a.foo</code> would.<p>We'll talk about a few more interesting cases before moving on:<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>is-superselector</span><span>("</span><span style=color:#59c2ff;>a</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#59c2ff;>b</span><span>")
</span><span style=font-style:italic;color:#5c6773;>// false
</span></code></pre><p>Two selectors that have no overlap can never be superselectors or subselectors of the other.<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>is-superselector</span><span>("</span><span style=color:#59c2ff;>a b</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#59c2ff;>a </span><span style=color:#bfbab0cc;>> </span><span style=color:#59c2ff;>b</span><span>")
</span><span style=font-style:italic;color:#5c6773;>// true
</span><span style=color:#59c2ff;>is-superselector</span><span>("</span><span style=color:#59c2ff;>a b</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#59c2ff;>a </span><span style=color:#bfbab0cc;>+ </span><span style=color:#59c2ff;>b</span><span>")
</span><span style=font-style:italic;color:#5c6773;>// false
</span><span style=color:#59c2ff;>is-superselector</span><span>("</span><span style=color:#59c2ff;>a b</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#59c2ff;>a </span><span style=color:#bfbab0cc;>~ </span><span style=color:#59c2ff;>b</span><span>")
</span><span style=font-style:italic;color:#5c6773;>// false
</span><span style=color:#59c2ff;>is-superselector</span><span>("</span><span style=color:#59c2ff;>a </span><span style=color:#bfbab0cc;>> </span><span style=color:#59c2ff;>b</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#59c2ff;>a b</span><span>")
</span><span style=font-style:italic;color:#5c6773;>// false
</span><span style=color:#59c2ff;>is-superselector</span><span>("</span><span style=color:#59c2ff;>a </span><span style=color:#bfbab0cc;>+ </span><span style=color:#59c2ff;>b</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#59c2ff;>a </span><span style=color:#bfbab0cc;>+ </span><span style=color:#59c2ff;>b</span><span>")
</span><span style=font-style:italic;color:#5c6773;>// true
</span></code></pre><p>This is where we have to start caring about the semantics of combinators. The interesting case here is that the descendant combinator (<code> </code>) is considered a superselector of the next child combinator (<code>></code>) while the inverse isn't true. The other combinators don't have any interesting interactions, though they <em>are</em> able to be superselectors of themselves.<p>Superselector calculations work on selector lists as well: <code>a, b</code> is a superselector of both <code>a</code> and <code>b</code>.<p>The universal selector (<code>*</code>) is a superselector of everything.<h5 id=specificity>Specificity</h5><p>The next primitive we need to introduce is selector specificity. Consider the following CSS,<pre class=language-css data-lang=css style=background-color:#0f1419;color:#bfbab0;><code class=language-css data-lang=css><span style=color:#59c2ff;>* </span><span>{
</span><span>    </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#f29668;>red</span><span style=color:#bfbab0cc;>;
</span><span>}
</span><span>
</span><span style=color:#59c2ff;>a </span><span>{
</span><span>    </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#f29668;>green</span><span style=color:#bfbab0cc;>;
</span><span>}
</span><span>
</span><span style=color:#ffb454;>#foo </span><span>{
</span><span>    </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#f29668;>orange</span><span style=color:#bfbab0cc;>;
</span><span>}
</span><span>
</span><span style=color:#ffb454;>.bar </span><span>{
</span><span>    </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#f29668;>blue</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>When we apply this stylesheet to the HTML <code>&LTa id="foo" class="bar" ... /></code>, what should the color be?<p>The style the browser chooses depends on the selector's <a href=https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity>specificity</a>. In this case, the id selector <code>#foo</code> is the most specific, so the color of the element will be <code>orange</code>.<p>The exact algorithm is this (quoting <a href=https://www.w3.org/TR/selectors-3/#specificity>the spec</a>):<blockquote><p>A selector's specificity is calculated as follows:<ul><li>count the number of ID selectors in the selector (= a)<li>count the number of class selectors, attributes selectors, and pseudo-classes in the selector (= b)<li>count the number of type selectors and pseudo-elements in the selector (= c)<li>ignore the universal selector</ul><p>Concatenating the three numbers a-b-c (in a number system with a large base) gives the specificity.</blockquote><p>This makes more sense if we walk through some examples. Take the selector <code>#foo.bar:hover::before *</code>. The specificity is calculated like this:<p>Our <code>a</code> value is the number of ID selectors, of which there is 1.<br> We have 1 class selector and 1 pseudo class selector, so our <code>b</code> value is 2.<br> There is 1 pseudo element selector, so our <code>c</code> value is 1.<p>If we concatenate these 3 numbers together, we get a specificity value of 121.<p>The spec walks through a number of other examples:<pre class=language-css data-lang=css style=background-color:#0f1419;color:#bfbab0;><code class=language-css data-lang=css><span style=color:#59c2ff;>*               </span><span style=font-style:italic;color:#5c6773;>/* a=0 b=0 c=0 -> specificity =   0 */
</span><span>LI              </span><span style=font-style:italic;color:#5c6773;>/* a=0 b=0 c=1 -> specificity =   1 */
</span><span>UL LI           </span><span style=font-style:italic;color:#5c6773;>/* a=0 b=0 c=2 -> specificity =   2 */
</span><span>UL OL</span><span style=color:#bfbab0cc;>+</span><span>LI        </span><span style=font-style:italic;color:#5c6773;>/* a=0 b=0 c=3 -> specificity =   3 */
</span><span>H1 </span><span style=color:#bfbab0cc;>+ </span><span style=color:#59c2ff;>*</span><span>[</span><span style=color:#ffb454;>REL</span><span style=color:#f29668;>=</span><span style=color:#c2d94c;>up</span><span>]  </span><span style=font-style:italic;color:#5c6773;>/* a=0 b=1 c=1 -> specificity =  11 */
</span><span>UL OL LI</span><span style=color:#ffb454;>.red    </span><span style=font-style:italic;color:#5c6773;>/* a=0 b=1 c=3 -> specificity =  13 */
</span><span>LI</span><span style=color:#ffb454;>.red.level    </span><span style=font-style:italic;color:#5c6773;>/* a=0 b=2 c=1 -> specificity =  21 */
</span><span style=color:#ffb454;>#x34y           </span><span style=font-style:italic;color:#5c6773;>/* a=1 b=0 c=0 -> specificity = 100 */
</span><span style=color:#ffb454;>#s12</span><span>:not(FOO)   </span><span style=font-style:italic;color:#5c6773;>/* a=1 b=0 c=1 -> specificity = 101 */
</span></code></pre><p>An interesting bit here is that the <code>:not(..)</code> pseudo class takes on the specificity of the selector that it contains and itself does not have any bearing on the calculation.<p>Sass makes some pretty strict guarantees about selector specificity.<p>First, it differentiates between user provided selectors and selectors that Sass generates through executing <code>@extend</code>.<p>Sass will never alter the specificity of user provided selectors. For example, it we take a stylesheet like this:<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>a</span><span style=color:#ffb454;>.foo </span><span>{
</span><span>    </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#f29668;>red</span><span style=color:#bfbab0cc;>;
</span><span>}
</span><span>
</span><span style=color:#59c2ff;>a </span><span>{
</span><span>    </span><span style=color:#ff7733;>@extend </span><span style=color:#ffb454;>.foo</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>What should the resulting selector be? If we were to ignore specificity, we'd probably expect the result to just be <code>a</code>. This is because <code>a</code> is a superselector of <code>a.foo</code>, so the semantics of <code>a, a.foo</code> would be the same as <code>a</code>.<p>However, the specificity of the selector plays into the semantics. If we were to treat <code>a.foo</code> as redundant and only emit <code>a</code>, that would leave us with a lower specificity than what the programmer originally wrote.<p>The solution here is to emit <code>a, a.foo</code> which maintains the semantics and specificity of both the original selector as written and the extension.<p>For selectors that Sass generates, things are a bit different. Sass only guarantees that generated selectors will have at least the specificity of the <em>extender</em>. That is, if we have an input like<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>a </span><span>{
</span><span>    </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#f29668;>red</span><span style=color:#bfbab0cc;>;
</span><span>}
</span><span>
</span><span style=color:#59c2ff;>a</span><span style=color:#ffb454;>.foo </span><span>{
</span><span>    </span><span style=color:#ff7733;>@extend </span><span style=color:#59c2ff;>a</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>where our extender is <code>a.foo</code>, Sass guarantees that it will output a selector at least as specific as <code>a.foo</code>. Our result is<pre class=language-css data-lang=css style=background-color:#0f1419;color:#bfbab0;><code class=language-css data-lang=css><span style=color:#59c2ff;>a</span><span style=color:#bfbab0cc;>, </span><span style=color:#59c2ff;>a</span><span style=color:#ffb454;>.foo </span><span>{
</span><span>  </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span>true</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>which is quite similar to our previous example. Where things differ is when our extendee is more specific than our extender.<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>a</span><span style=color:#bfbab0cc;>, </span><span style=color:#59c2ff;>a</span><span style=color:#ffb454;>.foo </span><span>{
</span><span>    </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span style=font-style:italic;color:#f29668;>red</span><span style=color:#bfbab0cc;>;
</span><span>}
</span><span>
</span><span style=color:#59c2ff;>b </span><span>{
</span><span>    </span><span style=color:#ff7733;>@extend </span><span style=color:#59c2ff;>a</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>Here, our extender <code>b</code> has a specificity of <code>1</code>. When we execute this code for the most recent version of Sass, we get<pre class=language-css data-lang=css style=background-color:#0f1419;color:#bfbab0;><code class=language-css data-lang=css><span style=color:#59c2ff;>a</span><span style=color:#bfbab0cc;>, </span><span style=color:#59c2ff;>b</span><span style=color:#bfbab0cc;>, </span><span style=color:#59c2ff;>a</span><span style=color:#ffb454;>.foo </span><span>{
</span><span>  </span><span style=color:#39bae6;>color</span><span style=color:#bfbab0cc;>: </span><span>true</span><span style=color:#bfbab0cc;>;
</span><span>}
</span></code></pre><p>There's a pretty noticeable omission of <code>b.foo</code> here. Although this affects the semantics of our styles, Sass is free to omit this selector as an optimization as it doesn't violate the guarantee that the generated selector will have a specificity of at least that of the extender.<h4 id=selector-unification>Selector unification</h4><p>The next primitive we need to introduce is the concept of selector unification.<p>When we "unify" two selectors, we create a new selector that matches only the elements that are matched by both selectors. This is like taking the "and" of two selectors.<p>Unification is fallible and will return <code>null</code> if it's not possible to represent the "and" of both selectors. For example, <code>selector-unify("#a", "#b)</code> will fail because <code>#a#b</code> would never match any elements.<p>As before, we'll walk through a couple examples to get an idea of how this primitive works.<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>selector-unify</span><span>("</span><span style=color:#ffb454;>.a</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#ffb454;>.b</span><span>")
</span></code></pre><p>This is a pretty simple example. To match both class selectors, we just concatenate them into <code>.a.b</code>. Most unifications of simple selectors end up just concatenating the two, unless they're a special case like two ids, two pseudo elements, two type selectors, or <code>*</code>.<p>In the case of <code>*</code>, for most combinations the result is just the other selector. You can think of it sort of like <code>true && X</code>. Our result is always just <code>X</code>. Things get a bit more complex when namespaces are involved, but we won't dive into that here.<p>Unification of complex selectors is a bit more.... complex :p<p>I think it's helpful if we revisit the semantics of unification. Our goal is to create one selector that combines 2 selectors, A and B, and which matches the elements matched by <em>both</em> A and B.<p>If we look at an example like <code>.a .b</code>, semantically this is matching all <code>.b</code> elements with a <code>.a</code> parent. For the selector <code>.c .d</code>, the same is true -- we're selecting all <code>.d</code> elements with a <code>.c</code> parent.<p>If we want to unify these two selectors, what should the semantics of the resulting selector look like?<p>We'd want a selector that matches all child elements that are <em>both</em> <code>.b</code> and <code>.d</code> and that have parents of <code>.a</code> and <code>.c</code>. Modelling the children is pretty easy -- we just unify the children selectors to get <code>.b.d</code>. The parents are a bit harder -- how do you model having both parents <code>.a</code> and <code>.c</code>.<p>The solution is to emit all possible orderings of <code>.a</code> and <code>.c</code>. Specifically we would emit <code>.a .c</code>, <code>.c .a</code>, and also <code>.a.c</code> to account for the case in which a parent has both classes.<p>Putting this together, we get the final selector of <code>.a .c .b.d, .c .a .b.d, .a.c .b.d</code>. In practice, implementations of Sass omit the <code>.a.c</code> selector because it results in <em>much</em> larger selectors for marginal gain.<p>Let's zoom into this algorithm to see how we'd go about generating this selector.<p>We start by looking at the last compound selector of both complex selectors and trying to unify them. We refer to this final value as the "base." If unification of the compound bases fails, the entire unification will fail as well.<p>Let's walk through a 2 examples of this:<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>selector-unify</span><span>("</span><span style=color:#59c2ff;>a </span><span style=color:#ffb454;>.foo</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#59c2ff;>a </span><span style=color:#ffb454;>.bar</span><span>")
</span></code></pre><p>Here, unification of the two base selectors succeeds and gives us <code>.foo.bar</code>, making our final unified selector <code>a .foo.bar</code>.<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>selector-unify</span><span>("</span><span style=color:#59c2ff;>a </span><span style=color:#ffb454;>#foo</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#59c2ff;>a </span><span style=color:#ffb454;>#bar</span><span>")
</span></code></pre><p>In this example, <code>#foo</code> and <code>#bar</code> can't be unified, and so the entire result is <code>null</code>.<p>Once we resolve and unify the bases, we need to unify the parent selectors. We refer the algorithm that does this as "weave."<h5 id=weave>Weave</h5><p>The goal of <code>weave</code> is to generate all possible orderings of the parent selectors. Earlier we looked at a pretty simple example, but weaving can get pretty complex. In particular, we run into increased complexity when we have combinators other than descendant (<code>></code>, <code>+</code>, or <code>~</code>), we have multiple parent selectors (e.g. <code>.a .b .c</code> and <code>.d .e .f</code>), or if the parents share a selector either with each other or the base.<p>Weaving maintains the invariant that the relative ordering of compound selectors within a given complex selector will remain the same. That is, if we are merging <code>.a .b .c</code> and <code>.d .e .f</code>, <code>.a</code> will always come before <code>.b</code> and <code>.d</code> will always come before <code>.e</code>. This should make sense intuitively -- if we swapped the order of <code>.a</code> and <code>.b</code>, we would be modifying the semantics of the original selector.<p>We'll start by looking at some examples of these more complex cases, and then we'll take a deeper look at the implementation.<p>The first complex case is when there are multiple parent selectors. Take this example:<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>selector-unify</span><span>("</span><span style=color:#ffb454;>.a .b .c</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#ffb454;>.d .c</span><span>");
</span></code></pre><p>Unification gives us <code>.a .b .d .c, .d .a .b .c</code>. We put the parent of selector 2 on both sides of selector 1.<p>Based on our explanation so far, you might imagine that Sass would attempt to interleave the <code>.d</code> selector between <code>.a .b</code>, producing the parent <code>.a .d .b</code>; however, Sass doesn't do this for the same reason it doesn't emit <code>.a.c</code> or <code>.b.c</code>.<p>For completeness, if we look at an example where <em>both</em> selectors have multiple parent selectors,<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>selector-unify</span><span>("</span><span style=color:#ffb454;>.a .b .c</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#ffb454;>.d .e .c</span><span>");
</span></code></pre><p>we get <code>.a .b .d .e .c, .d .e .a .b .c</code>. Again, there's no interleaving of the selectors from the two parents. We simply change their ordering.<p>When the two selectors share a common compound selector, we can often emit a much smaller result.<p>The case in which the first parents are the same should be pretty intuitive --<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>selector-unify</span><span>("</span><span style=color:#ffb454;>.a .b .c</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#ffb454;>.a .d .c</span><span>");
</span></code></pre><p>Here, we can maintain the semantics of both selectors by only permuting the middle compound selector. Our unification result is <code>.a .b .d .c, .a .d .b .c</code>.<p>If the selectors instead share a middle compound selector, we can do a similar trick.<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>selector-unify</span><span>("</span><span style=color:#ffb454;>.a .b .c</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#ffb454;>.e .b .c</span><span>");
</span></code></pre><p>Our result is <code>.a .e .b .c, .e .a .b .c</code>. We keep <code>.b .c</code> the same between both complex selectors, but we permute <code>.a</code> and <code>.e</code>.<p>In both cases that we've seen here, not de-duplicating the selector would change the semantics of the unified result from that of the original selectors. In our first case, if Sass had emitted <code>.a .a .b .d .c</code>, the additional <code>.a</code> would not only be superfluous -- it would be incorrect. The original selectors being unified only required a single <code>.a</code> parent.<p>The next complex case to look at is when we have to worry about combinators.<p>Before discussing combinators further though, I do want to mention that Sass today is in the process of <a href=https://github.com/sass/sass/issues/3340>changing how it handles invalid combinator sequences</a>. For this reason I will be skipping over talking about parts of the existing algorithm that attempt to handle them gracefully.<p>Let's go back to the simplest unify example that we've looked at: <code>selector-unify(".a .c", ".b .c")</code>. Hopefully you remember what the unified result is -- <code>.a .b .c, .b .a .c</code>. This should make sense so far. But what happens if we insert a combinator into the mix?<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>selector-unify</span><span>("</span><span style=color:#ffb454;>.a </span><span style=color:#bfbab0cc;>> </span><span style=color:#ffb454;>.c</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#ffb454;>.b .c</span><span>")
</span></code></pre><p>How should the result be updated to account for the combinator?<p>It helps to look at the two complex selectors separately, <code>.a .b .c</code> and <code>.b .a .c</code>. For the latter, it's pretty straightforward; we can maintain the semantics by simply adding a combinator between <code>.a</code> and <code>.c</code>: <code>.b .a > .c</code>.<p>For the former case, it's harder to reason about. Should the combinator go between the <code>.a</code> and <code>.b</code> or the <code>.b</code> and <code>.c</code>. The answer is actually neither -- Sass completely discards the second complex selector. Our final unified result is <code>.b .a > .c</code>.<p>This can be pretty surprising -- why do we throw away the second complex selector? The answer is that it's impossible to model the semantics of <code>.a > .c</code> while adding a parent in between. The same is true of all combinators other than descendant: <code>></code>, <code>+</code>, and <code>~</code>.<p>Things get even more complex when both selectors contain combinators other than descendant.<p>Let's start with the case in which the combinators on both sides are the same,<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>selector-unify</span><span>("</span><span style=color:#ffb454;>.a </span><span style=color:#bfbab0cc;>> </span><span style=color:#ffb454;>.c</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#ffb454;>.b </span><span style=color:#bfbab0cc;>> </span><span style=color:#ffb454;>.c</span><span>")
</span><span style=color:#59c2ff;>selector-unify</span><span>("</span><span style=color:#ffb454;>.a </span><span style=color:#bfbab0cc;>+ </span><span style=color:#ffb454;>.c</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#ffb454;>.b </span><span style=color:#bfbab0cc;>+ </span><span style=color:#ffb454;>.c</span><span>")
</span><span style=color:#59c2ff;>selector-unify</span><span>("</span><span style=color:#ffb454;>.a </span><span style=color:#bfbab0cc;>~ </span><span style=color:#ffb454;>.c</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#ffb454;>.b </span><span style=color:#bfbab0cc;>~ </span><span style=color:#ffb454;>.c</span><span>")
</span></code></pre><p>The semantics of the combinators here affects how we can unify the two selectors. For <code>></code> and <code>+</code>, the only valid unification is one in which the parent of <code>.c</code> has both <code>.a</code> and <code>.b</code>. That is, our total result is <code>.a.b .c</code>.<p>The sibling combinator <code>~</code> is a less restrictive. The semantics of the unified selector should be that <code>.c</code> is a sibling of <code>.a</code> <em>and</em> <code>.b</code>. If we express these semantics terms of selectors, our possible parents are <code>.a ~ .b</code>, <code>.b ~ .a</code>, and <code>.a.b</code>. This is very similar to how we do unification without combinators -- just with an additional <code>~</code>. Our final result would be <code>.a ~ .b ~ .c, .b ~ .a ~ .c, .b.a ~ .c</code>.<p>Unlike regular unification without combinators, Sass actually does emit the <code>.b.a</code> case here. This is because the likelihood of this parent selector occurring in the context of the <code>~</code> combinator is much higher than in the general case.<p>The case in which combinators are not the same is interesting as well:<pre class=language-scss data-lang=scss style=background-color:#0f1419;color:#bfbab0;><code class=language-scss data-lang=scss><span style=color:#59c2ff;>selector-unify</span><span>("</span><span style=color:#ffb454;>.a </span><span style=color:#bfbab0cc;>> </span><span style=color:#ffb454;>.c</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#ffb454;>.b </span><span style=color:#bfbab0cc;>~ </span><span style=color:#ffb454;>.c</span><span>")
</span><span style=color:#59c2ff;>selector-unify</span><span>("</span><span style=color:#ffb454;>.a </span><span style=color:#bfbab0cc;>> </span><span style=color:#ffb454;>.c</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#ffb454;>.b </span><span style=color:#bfbab0cc;>+ </span><span style=color:#ffb454;>.c</span><span>")
</span><span style=color:#59c2ff;>selector-unify</span><span>("</span><span style=color:#ffb454;>.a </span><span style=color:#bfbab0cc;>+ </span><span style=color:#ffb454;>.c</span><span>"</span><span style=color:#bfbab0cc;>,</span><span> "</span><span style=color:#ffb454;>.b </span><span style=color:#bfbab0cc;>~ </span><span style=color:#ffb454;>.c</span><span>")
</span></code></pre><p>For unification involving the <code>></code> combinator, the result is simple. <code>.a</code> becomes the parent of the other selector: <code>.a > .b ~ .c</code> and <code>.a > .b + .c</code>.<p>When combining <code>+</code> and <code>~</code>, we have to take into account that both combinators refer to sibling elements, with <code>~</code> being a more general version of <code>+</code>. Like when there are two <code>~</code> combinators, we have to permute both parent selectors. But in the case that one of the combinators is a <code>+</code>, we can omit one of the permutations.<p>Our final selector would be <code>.b ~ .a + .c, .b.a + .c</code>. Note that we didn't include the <code>.a ~ .b</code> variant, because that would be redundant.<h4 id=putting-it-all-together>Putting it All Together</h4><p>Now that we've covered the primitives of extend, we need to combine them together to get the actual algorithm.<p>Extension occurs during traversal of the Sass AST. When a selector node is encountered, it is registered in an "extension store." The extension store contains the state of all extensions of the current execution context. Namely, it maintains a mapping from simple selectors to the selector lists containing them and a mapping from simple selectors to the extensions containing them (i.e. the <code>@extend</code> rules having the simple selector as an extender).<p>The extension store also keeps tracks of source specificity and the original selectors as declared by the source code. This is done in order to maintain the invariant that Sass doesn't elide selectors as declared by users.<p>When a selector is registered in the extension store, the mapping from simple selectors to the selectors containing them is populated. Then, if we have encountered any <code>@extend</code> rules up to this point, we apply them to the selector. We will have to update this selector again if we encounter further <code>@extend</code> rules during execution.<p>The process of applying an extension is where we get to use the primitives we discussed earlier.<h4 id=addendum>Addendum</h4><p>...<h5 id=not>:not</h5><h5 id=is-matches-where>:is/:matches/:where</h5><h5 id=root>:root</h5><h5 id=has>:has</h5><h5 id=interactions-with-media>Interactions with @media</h5><h5 id=optional>!optional</h5><p>Sass notably makes an optimization by not emitting the <code>.a.b</code> parent selector in the unification of <code>.a .c</code> and <code>.b .c</code>. This is because</section></article></main></div><script>window.addEventListener('load', function () {
            for (const ref of document.getElementsByClassName('footnote-reference')) {
                const hash = ref.children[0].hash.substring(1);
                const refhash = 'ref:' + hash;
                ref.id = refhash;
            }

            for (const footnote of document.getElementsByClassName('footnote-definition')) {
                const hash = footnote.id;
                const refhash = 'ref:' + hash;
                const backlink = document.createElement('a');
                backlink.href = '#' + refhash;
                backlink.className = 'footnote-backlink';
                backlink.innerText = '↩';
                const paras = footnote.children;
                const lastPara = paras[paras.length - 1];
                lastPara.appendChild(backlink);
            }
        });</script><script type=module>/*! instant.page v5.2.0 - (C) 2019-2023 Alexandre Dieulot - https://instant.page/license */
        let t, e, n, o, i, a = null, s = 65, c = new Set; const r = 1111; function d(t) { o = performance.now(); const e = t.target.closest("a"); m(e) && p(e.href, "high") } function u(t) { if (performance.now() - o < r) return; if (!("closest" in t.target)) return; const e = t.target.closest("a"); m(e) && (e.addEventListener("mouseout", f, { passive: !0 }), i = setTimeout(() => { p(e.href, "high"), i = void 0 }, s)) } function l(t) { const e = t.target.closest("a"); m(e) && p(e.href, "high") } function f(t) { t.relatedTarget && t.target.closest("a") == t.relatedTarget.closest("a") || i && (clearTimeout(i), i = void 0) } function h(t) { if (performance.now() - o < r) return; const e = t.target.closest("a"); if (t.which > 1 || t.metaKey || t.ctrlKey) return; if (!e) return; e.addEventListener("click", function (t) { 1337 != t.detail && t.preventDefault() }, { capture: !0, passive: !1, once: !0 }); const n = new MouseEvent("click", { view: window, bubbles: !0, cancelable: !1, detail: 1337 }); e.dispatchEvent(n) } function m(o) { if (o && o.href && (!n || "instant" in o.dataset)) { if (o.origin != location.origin) { if (!(e || "instant" in o.dataset) || !a) return } if (["http:", "https:"].includes(o.protocol) && ("http:" != o.protocol || "https:" != location.protocol) && (t || !o.search || "instant" in o.dataset) && !(o.hash && o.pathname + o.search == location.pathname + location.search || "noInstant" in o.dataset)) return !0 } } function p(t, e = "auto") { if (c.has(t)) return; const n = document.createElement("link"); n.rel = "prefetch", n.href = t, n.fetchPriority = e, n.as = "document", document.head.appendChild(n), c.add(t) } !function () { if (!document.createElement("link").relList.supports("prefetch")) return; const o = "instantVaryAccept" in document.body.dataset || "Shopify" in window, i = navigator.userAgent.indexOf("Chrome/"); i > -1 && (a = parseInt(navigator.userAgent.substring(i + "Chrome/".length))); if (o && a && a < 110) return; const c = "instantMousedownShortcut" in document.body.dataset; t = "instantAllowQueryString" in document.body.dataset, e = "instantAllowExternalLinks" in document.body.dataset, n = "instantWhitelist" in document.body.dataset; const r = { capture: !0, passive: !0 }; let f = !1, v = !1, g = !1; if ("instantIntensity" in document.body.dataset) { const t = document.body.dataset.instantIntensity; if (t.startsWith("mousedown")) f = !0, "mousedown-only" == t && (v = !0); else if (t.startsWith("viewport")) { const e = navigator.connection && navigator.connection.saveData, n = navigator.connection && navigator.connection.effectiveType && navigator.connection.effectiveType.includes("2g"); e || n || ("viewport" == t ? document.documentElement.clientWidth * document.documentElement.clientHeight < 45e4 && (g = !0) : "viewport-all" == t && (g = !0)) } else { const e = parseInt(t); isNaN(e) || (s = e) } } v || document.addEventListener("touchstart", d, r); f ? c || document.addEventListener("mousedown", l, r) : document.addEventListener("mouseover", u, r); c && document.addEventListener("mousedown", h, r); if (g) { let t = window.requestIdleCallback; t || (t = (t => { t() })), t(function () { const t = new IntersectionObserver(e => { e.forEach(e => { if (e.isIntersecting) { const n = e.target; t.unobserve(n), p(n.href) } }) }); document.querySelectorAll("a").forEach(e => { m(e) && t.observe(e) }) }, { timeout: 1500 }) } }();</script>